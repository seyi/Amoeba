/*	@(#)Tpipe.c	1.3	96/02/27 10:56:07 */
/*
 * Copyright 1995 Vrije Universiteit, The Netherlands.
 * For full copyright and restrictions on use see the file COPYRIGHT in the
 * top level of the Amoeba distribution.
 */

/*
 * File		: Tpipe.c
 *
 * Original	: May 31, 1991.
 * Author(s)	: Berend Jan Beugel (beugel@cs.vu.nl).
 * Description	: Test suite for pipes between processes.
 *
 * Update 1	:
 * Author(s)	:
 * Description	:
 */


#include	<test.h>
#include	<stdio.h>
#include	<stdlib.h>
#include	<string.h>
#include        <errno.h>
#include	<signal.h>
#include	<fcntl.h>


/* General stuff. Should go into a separate header file sometime. */
#define	PRIVATE	static
#define PUBLIC
#define EXTERN	extern

#define TRUE	1
#define FALSE	0
#define	OK	0


typedef	int		bool;
typedef	unsigned char	byte;


/* Global flag controlling the output of tests. */
PRIVATE	bool	verbose   = FALSE;	/* Give lots of info on tests. */
PRIVATE bool    goodf     = FALSE;      /* Only test with valid arguments. */
PRIVATE bool    badf      = FALSE;      /* Only test with invalid arguments. */


/* The name of the current test_procedure. */
PRIVATE char	testname[32] = "";

#define	STDOUT	1	/* Filedescriptors for 'stdout' and */
#define	STDERR	2	/* 'stderr'.			    */
#define ERR	-1
#define	READ	0	/* Indices for the reading and */
#define	WRITE	1	/* writing side of a pipe.     */
#define	BUFSIZE	4096
#define	NBUFS	8

PRIVATE	int	fd[2];		/* Filediscriptors for a pipe. */
PRIVATE	int	bad_fd1[2];	/* A pipe for testing error conditions. */
PRIVATE	int	bad_fd2[2];	/* A pipe for testing error conditions. */
PRIVATE	byte	*buff;		/* Read and write buffer. */
PRIVATE int	buffsize = BUFSIZE;
PRIVATE int	nbufs	 = NBUFS;	/* Nr. of buffers to be written. */
PRIVATE int	glo_sig	 = 0;

/* Externally defined variables. */
EXTERN  int     sys_nerr;
EXTERN  char    *sys_errlist[];
EXTERN  int     errno;




PRIVATE	bool	test_ok(err, testcode)
/* Checks the error code returned by supporting function calls.
 * Returns FALSE if 'err' == ERR and (sub)test has to be aborted.
 */

int	err;
char	testcode[];
{
  char  *s;


  s = errno < sys_nerr ? sys_errlist[errno] : "unknown error";

  TEST_ASSERT(err != ERR, TEST_SERIOUS,
                ("%s, %s (%s, test aborted)\n", testname, testcode, s));
  if (err != ERR) {
    if (verbose)
      printf("passed: %s, %s\n", testname, testcode);

    return TRUE;
  }
  else
    return FALSE;

}  /* test_ok() */




PRIVATE	bool	test_good(err, testcode)
/* Checks if a tested function call returned no error.
 * Returns TRUE if 'err' != ERR.
 */

int	err;
char	testcode[];
{
  char  *s;


  s = errno < sys_nerr ? sys_errlist[errno] : "unknown error";

  TEST_ASSERT(err != ERR, TEST_SERIOUS,
                ("%s, %s (%s)\n", testname, testcode, s));
  if (err != ERR) {
    if (verbose)
      printf("passed: %s, %s\n", testname, testcode);

    return TRUE;
  }
  else
    return FALSE;

}  /* test_good() */




PRIVATE	bool	test_bad(err, exp, testcode, argname)
/* Checks if a tested function call returned an error.
 * Returns TRUE if 'err' == ERR.
 */

int	err, exp;
char	testcode[], argname[];
{
  char  *serr, *sexp;


  TEST_ASSERT(err == ERR, TEST_SERIOUS,
	("%s, %s (no error for %s)\n", testname, testcode, argname));
  if (err == ERR) {
    if (exp != OK)
      TEST_ASSERT(errno == exp, TEST_SERIOUS,
        ("%s, %s (wrong error for %s)\n", testname, testcode, argname));

    if (verbose) {
      serr = errno < sys_nerr ? sys_errlist[errno] : "unknown error";
      sexp = exp < sys_nerr ? sys_errlist[exp] : "unknown error";

      if (errno != exp && exp != OK)
        printf("expected error: %s    returned error: %s\n", sexp, serr);
      else
        printf("passed: %s, %s (%s)\n", testname, testcode, serr);
    }

    return TRUE;
  }
  else
    return FALSE;

}  /* test_bad() */




PRIVATE	void	handler(sig)
/* Handles a SIGPIPE signal generated by writing on a pipe closed on the
 * reading side. Sets a global variable to be checked later.
 */

int	sig;
{
  glo_sig = sig;

}  /* handler() */




PRIVATE	void	test_pipe_write()

{
  int	nbytes;
  int	i, j;
  byte	*buffp;
  int	buffs;


  (void)strcpy(testname, "test_pipe_write()");
  if (verbose)  printf("\n----  %s  ----\n", testname);

  /* Write 'nbufs' buffers over the pipe. */
  for (i = 0; i < nbufs; i++) {

    /* Fill the buffer with random bytes. */
    for (j = 0; j < buffsize; j++)
      buff[j] = (byte)rand();

    /* Write over the pipe until the entire buffer has been writen. */
    buffp = buff;
    buffs = buffsize;
    while (test_good(nbytes = write(fd[WRITE], buffp, buffs), "write()")) {
      if (verbose || nbytes == 0)
        TEST_ASSERT(nbytes == buffs, TEST_SERIOUS,
                        ("%s: bytes written should be %d but is %d\n",
                                testname, buffs, nbytes));

      buffp += nbytes;
      buffs -= nbytes;
      if (buffs == 0 || nbytes == 0)
        break;
    }
  }

}  /* test_pipe_write() */




PRIVATE	void	test_pipe_read()

{
  int	nbytes;
  int	i, j;
  int	bcount = 0;
  byte	brnd;
  byte	*buffp;
  int	buffs;


  (void)strcpy(testname, "test_pipe_read()");
  if (verbose)  printf("\n----  %s  ----\n", testname);

  /* Read 'nbufs' buffers from the pipe. */
  for (i = 0; i < nbufs; i++) {

    /* Clear the buffer. */
    memset(buff, 0, (size_t)buffsize);

    /* Read from the pipe untill the entire buffer has been read. */
    buffp = buff;
    buffs = buffsize;
    while (test_good(nbytes = read(fd[READ], buffp, buffs), "read()")) {
      if (verbose || nbytes == 0)
        TEST_ASSERT(nbytes == buffs, TEST_SERIOUS,
                        ("%s: bytes read should be %d but is %d\n",
                                testname, buffs, nbytes));

      buffp += nbytes;
      buffs -= nbytes;
      if (buffs == 0 || nbytes == 0)
        break;
    }

    /* Check the contents of the buffer. */
    for (j = 0; j < (buffsize - buffs); j++) {
      bcount++;
      TEST_ASSERT(buff[j] == (brnd = (byte)rand()), TEST_SERIOUS,
                ("%s: byte nr. %d should be %X but is %X\n",
			testname, bcount, (int)buff[j], (int)brnd));
    }
  }

}  /* test_pipe_read() */




PRIVATE	void	test_pipe_bad_write()

{
  int	n;
  void	(*func)();


  (void)strcpy(testname, "test_pipe_bad_write()");
  if (verbose)  printf("\n----  %s  ----\n", testname);

  /* Set up the handler for the SIGPIPE signal. */
  (void)test_good((int)(func = signal(SIGPIPE, handler)), "signal()");

  for (n = 0; n < buffsize; n++)
    buff[n] = (byte)rand();

  /* Clear the signal. */
  glo_sig = 0;

  /* Write over a pipe closed on the reading side. */
  (void)test_bad(write(bad_fd1[WRITE], buff, buffsize),
					EPIPE, "write()", "closed pipe");

  /* Check that the SIGPIPE signal has indeed been generated. */
  TEST_ASSERT(glo_sig == SIGPIPE, TEST_SERIOUS,
		("%s: wrong signal %d caught\n", testname, glo_sig));

  (void)test_good((int)signal(SIGPIPE, func), "signal()");

}  /* test_pipe_bad_write() */




PRIVATE	void	test_pipe_bad_read()

{
  (void)strcpy(testname, "test_pipe_bad_read()");
  if (verbose)  printf("\n----  %s  ----\n", testname);

  memset(buff, 0, (size_t)buffsize);

  /* Read from a pipe closed on the writing side. */
  (void)test_bad(read(bad_fd2[READ], buff, buffsize),
						OK, "read()", "closed pipe");

}  /* test_pipe_bad_read() */




PRIVATE	int	usage(progname)
/* Print a message about how to use the test. */

char	progname[];
{
  fprintf(stderr, "Usage: %s [-vgb] [-s <buffersize>] [-n <# of buffers>]\n",
								progname);
  exit(1);

}  /* usage() */




PRIVATE	bool	test_init(child)
/* Sets up pipes, forks a child and redirects output. */

int	*child;
{
  int	fdes;
  char	s[16];


  (void)strcpy(testname, "test_init()");
  if (verbose)  printf("\n----  %s  ----\n", testname);

  /* Allocate the buffer for reading and writing. */
  if ((buff = (byte *)malloc(buffsize+1)) == NULL) {
    (void)test_ok(ERR, "malloc()");
    return(FALSE);
  }

  srand(getpid());

  if (goodf) {
    /* Set up a pipe for normal reading and writing. */
    if (!test_ok(pipe(fd), "pipe()"))
      return FALSE;
  }

  if (badf) {
    /* Set up pipes for testing error conditions. */
    if (!test_ok(pipe(bad_fd1), "pipe()"))
      return FALSE;

    if (!test_ok(pipe(bad_fd2), "pipe()"))
      return FALSE;
  }

  /* Fork a writer. */
  *child = fork();
  if (*child == ERR) {
    TEST_ASSERT(FALSE, TEST_SERIOUS,
                        ("%s (couldn't fork writer)\n", testname));

    return FALSE;
  }

  if (*child == 0) {

    /* This is the child (writer). Redirect 'stdout' and 'stderr' to a file. */
    sprintf(s, "pro%d.log", getpid());
    if (!test_ok((int)(fdes=open(s, O_WRONLY | O_CREAT | O_TRUNC)), "open()"))
      return FALSE;

    if (!test_ok(dup2((int)fdes, STDOUT), "dup2(fdes, STDOUT)"))
      return FALSE;
    if (!test_ok(dup2((int)fdes, STDERR), "dup2(fdes, STDERR)"))
      return FALSE;
  }

  if (*child == 0) {
    if (goodf)
      /* Close the pipe for reading on the writing side. */
      (void)test_good(close(fd[READ]), "close()");

    if (badf) {
      /* This side (the child) only writes. */
      (void)test_good(close(bad_fd1[READ]), "close()");

      /* Make sure the reading side reads from a pipe closed on
       * the writing side (i.e. this side).
       */
      (void)test_good(close(bad_fd2[WRITE]), "close()");
      (void)test_good(close(bad_fd2[READ]), "close()");
    }
  }
  else {
    if (goodf)
      /* Close the pipe for writing on the reading side. */
      (void)test_good(close(fd[WRITE]), "close()");

    if (badf) {
      /* This side (the parent) only reads. */
      (void)test_good(close(bad_fd2[WRITE]), "close()");

      /* Make sure the writing side writes to a pipe closed on
       * the reading side (i.e. this side).
       */
      (void)test_good(close(bad_fd1[WRITE]), "close()");
      (void)test_good(close(bad_fd1[READ]), "close()");
    }
  }

  return TRUE;

}  /* test_init() */




PRIVATE	void	test_cleanup(child)
/* Closes the pipes and lets the child exit. */

int	child;
{
  (void)strcpy(testname, "test_cleanup()");
  if (verbose)  printf("\n----  %s  ----\n", testname);

  if (child == 0) {
    if (goodf)
      (void)test_good(close(fd[WRITE]), "close()");
    if (badf)
      (void)test_good(close(bad_fd1[WRITE]), "close()");

    exit(0);
  }
  else {
    if (goodf)
      (void)test_good(close(fd[READ]), "close()");
    if (badf)
      (void)test_good(close(bad_fd2[READ]), "close()");
  }

}  /* test_cleanup() */




PUBLIC	int	main(argc, argv)

int	argc;
char	*argv[];
{
  char		c;
  extern char   *optarg;
  extern int	optind;
  int		child;
  int           status;
  int           fdes;
  void		(*func)();
  char		s[16];


  /* Check the command-line options. */
  while((c = getopt(argc, argv, "vgbs:n:")) != EOF) {
    switch(c) {
      case 'v': verbose  = TRUE;	 break;
      case 'g': goodf    = TRUE;	 break;
      case 'b': badf     = TRUE;	 break;
      case 's': buffsize = atoi(optarg); break;
      case 'n': nbufs    = atoi(optarg); break;

      default:  usage(argv[0]);
    }
  }

  /* Get the status of the SIGINT signal. */
  func = signal(SIGINT, SIG_DFL);
  (void)signal(SIGINT, func);

  /* If SIGINT is ignored this process runs on the background and
   * the output to 'stdout' and 'stderr' has to be redirected to a file.
   */
  if (func == SIG_IGN) {
    sprintf(s, "pro%d.log", getpid());
    if ((fdes = open(s, O_WRONLY | O_CREAT | O_TRUNC)) == ERR) {
      perror("open()");
      exit(0);
    }

    if (dup2(fdes, STDOUT) == ERR) {
      perror("dup2()");
      exit(0);
    }
    if (dup2(fdes, STDERR) == ERR) {
      perror("dup2()");
      exit(0);
    }
  }

  (void)setvbuf(stdout, NULL, _IOLBF, 0);
  (void)setvbuf(stderr, NULL, _IOLBF, 0);

  /* Check the size of the buffers to be piped. */
  if (buffsize < 0)
    buffsize = BUFSIZE;

  /* Check the number of buffers to be piped. */
  if (nbufs < 0)
    nbufs = NBUFS;

  /* Do all the tests by default. */
  if (!goodf && !badf)
    goodf = badf = TRUE;

  TEST_BEGIN(argv[0]);

  if (test_init(&child)) {
    if (child == 0) {
      /* The child only writes. */
      if (goodf)
        test_pipe_write();

      if (badf)
        test_pipe_bad_write();
    }
    else {
      /* The parent only reads. */
      if (goodf)
        test_pipe_read();

#ifdef NotYet
      if (badf)
        test_pipe_bad_read();
#endif
    }
  }
  test_cleanup(child);

  /* Wait for the child to exit. */
  while (wait(&status) > 0);

  TEST_END();

}  /* main() */

