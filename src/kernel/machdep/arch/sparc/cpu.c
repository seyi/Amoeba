/*	@(#)cpu.c	1.5	96/02/27 13:46:39 */
/*
 * Copyright 1994 Vrije Universiteit, The Netherlands.
 * For full copyright and restrictions on use see the file COPYRIGHT in the
 * top level of the Amoeba distribution.
 */

/*
 * FILE: cpu.c -- deal with the cpu, including traps, stacks, and other cruft
 *
 * Traps funnel in through trap_begin() and out through trap_end() with all
 * manner of things happening between the two. Overflow and underflow handlers
 * have their own entry points, since they do not have a full window of
 * registers. 
 * 
 * Author: Philip Shafer <phil@procyon.ics.Hawaii.Edu>
 *	   (Univerity of Hawai'i, Manoa) November 1990
 *	   Greg Sharp and Hans van Staveren, Jan-March 1993 heavy munging.
 */

#define MPX
#include "amoeba.h"
#include "stderr.h"
#include "debug.h"
#include "machdep.h"
#include "promid_sun4.h"
#include "global.h"
#include "exception.h"
#include "kthread.h"
#include "fault.h"
#include "map.h"
#include "process/proc.h"
#include "psr.h"
#include "fsr.h"
#include "interrupt.h"
#include "sys/proto.h"
#include "module/buffers.h"
#include "assert.h"
#include "sys/flip/measure.h"
INIT_ASSERT

/* Definitions generated by "as.S" */
extern struct trap_vector trap_table[],
    trap_template, trap_overflow_template, trap_underflow_template;

extern char *sparc_gettbr();
extern void sparc_settbr();
extern void fast_flush_windows();
extern int setints();
#ifndef NOPROC
extern phys_bytes umap();
extern void sparc_syscall();
#endif
extern void prof_start_clock();
extern void prof_stop_clock();
extern void user_prof_tick();

/* The following is from the mmu code and tells us where kernel virtual
 * memory must end!  Thus we can detect bogus pointers while dumping
 * stacktraces
 */
extern vir_bytes mmu_maxaddr;

/* The following is used in as.S */
int curpid;

/* Indication from upper layers that a signal is pending for this thread */
extern long thread_sigpend;

/*
 * The trap_function array maps trap number (`tt' fields) into routines that
 * should be called to tend to that particular trap.
 */
void (*trap_function[ NUM_TRAPV ])();


#ifdef NDEBUG
#define NAMED( x )
#else
#define NAMED( x )	x
#endif

static struct intname {
    signum	e_sig;
#ifndef NDEBUG
    char	*e_name;
#endif
} error[] = {
    {	EXC_ABT,	NAMED( "unknown trap" ) },
    {	EXC_ACC,	NAMED( "instruction_access_exception" ) },
    {	EXC_ILL,	NAMED( "illegal_instruction" ) },
    {	EXC_ILL,	NAMED( "priviledged_instruction" ) },
    {	EXC_FPE,	NAMED( "fp_disabled" ) },
    {	EXC_ACC,	NAMED( "window_overflow" ) },
    {	EXC_ACC,	NAMED( "window_underflow" ) },
    {	EXC_ODD,	NAMED( "mem_address_not_aligned" ) },
    {	EXC_FPE,	NAMED( "fp_exception" ) },
    {	EXC_ACC,	NAMED( "data_access_exception" ) },
    {	EXC_ARG,	NAMED( "tag_overflow" ) },
    { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, { 0 }, /* 11-16 */
    {	EXC_BPT,	NAMED( "int_1" ) },
    {	EXC_BPT,	NAMED( "int_2" ) },
    {	EXC_BPT,	NAMED( "int_3" ) },
    {	EXC_BPT,	NAMED( "int_4" ) },
    {	EXC_BPT,	NAMED( "int_5" ) },
    {	EXC_BPT,	NAMED( "int_6" ) },
    {	EXC_BPT,	NAMED( "int_7" ) },
    {	EXC_BPT,	NAMED( "int_8" ) },
    {	EXC_BPT,	NAMED( "int_9" ) },
    {	EXC_BPT,	NAMED( "int_a" ) },
    {	EXC_BPT,	NAMED( "int_b" ) },
    {	EXC_BPT,	NAMED( "int_c" ) },
    {	EXC_BPT,	NAMED( "int_d" ) },
    {	EXC_BPT,	NAMED( "int_e" ) },
    {	EXC_BPT,	NAMED( "int_f" ) },
    { 0 }, { 0 }, { 0 }, { 0 }, /* 32-35 */
    {	EXC_FPE,	NAMED( "cp_disabled" ) },
    { 0 }, { 0 }, { 0 }, /* 37-39 */
    {	EXC_FPE,	NAMED( "cp_exception" ) },
};
static int numerrors = sizeof( error ) / sizeof( error[ 0 ]);

#if !defined(NDEBUG)

int
interrupts_enabled()
{
    unsigned long psr;

    psr = sparc_getpsr();
    return ((psr & PSR_PIL) == 0 && (psr & PSR_ET) != 0);
}

#endif /* NDEBUG */

puttrap( reason )
int reason;
{
    signum	sig;

    fast_flush_windows();
    if ( reason < 0 || reason >= numerrors ) {
	switch (reason) {
	case TRAPV_TRAPBASE + TRAPV_BPTFLT:
	    sig = EXC_BPT;
	    break;
	case TRAPV_TRAPBASE + TRAPV_DIVZERO:
	    sig = EXC_DIV;
	    break;
	default:
	    sig = EXC_ABT;
	    break;
	}
    } else
	sig = error[ reason ].e_sig;
    putsig( curthread, sig );
}

#ifndef NOPROC

thread_ustate *
swtrap(sig, framep)
signum sig;
thread_ustate *framep;
{
    BEGIN_MEASURE(sig_swtrap);
    fast_flush_windows();
    if ( usertrap( sig, framep ) == 0 )
	exitthread((long *) 0);
    framep->tu_pid = PROCSLOT(curthread->mx_process);
    framep->tu_psr |= PSR_S;
    framep->tu_psr &= ~(PSR_PIL | PSR_PS | PSR_ET);
    END_MEASURE(sig_swtrap);
    return framep;
}

/*
 * This routine is called if a window overflow trap finds there is no more
 * stack on which to save the register windows.  It simply knocks the
 * offending process on the head.
 */
void
trp_stkoverflow(framep)
thread_ustate *framep;
{
    if (!userthread())
	panic("trp_stkoverflow: kernel stack overflow\n");
    putsig(curthread, (signum) EXC_ACC);
    swtrap((signum) EXC_ACC, framep);

    /* If we get back here, the owner is telling us to continue
     * this thread.  But there's no way we can do that..
     */
    printf("trp_stkoverflow: killing thread\n");
    exitthread((long *) 0);
}


/*ARGSUSED*/
void
fp_disabled( reason, framep, pc, psr, pid )
int reason;				/* Trap type (from TBR) */
thread_ustate *framep;			/* Frame on kernel stack */
int pc;					/* Address of trapping instruction */
int psr;				/* Original PSR (right after trap) */
int pid;				/* Process ID number */
{
    int i;

    /*
     * Process got a floating point disabled trap.
     * Enable it.
     */

    DPRINTF(2, ("Floating point disabled trap caught, psr=%x\n",
						framep->tu_psr));
    framep->tu_fsr = 0;
    framep->tu_qsize = 0;
    for (i=0; i<ARCH_NUMFPREGS; i++)
	framep->tu_float[i] = 0;
    for (i=0; i<ARCH_FPQSIZE; i++)
	framep->tu_fqueue[i] = 0;
    framep->tu_psr |= PSR_EF;
}


/*ARGSUSED*/
void
fp_exception( reason, framep, pc, psr, pid )
int reason;				/* Trap type (from TBR) */
thread_ustate *framep;			/* Frame on kernel stack */
int pc;					/* Address of trapping instruction */
int psr;				/* Original PSR (right after trap) */
int pid;				/* Process ID number */
{
    uint32	traptype;

    if (!userthread())
	panic("kernel got floating-point exception\n");
    DPRINTF(-1, ("fp_exception occurred\n"));
    traptype = (framep->tu_fsr & FSR_FTT) >> 14;
    DPRINTF(-1, ("fp_exception: trap type %d\n", traptype));
    switch (traptype)
    {
    case FSR_TT_NONE:
	printf("Got fp_exception while no exception pending!\n");
	return;

    case FSR_TT_EXC:
	DPRINTF(0, ("Got IEEE floating point exception\n"));
	break;

    case FSR_TT_UNFIN:
	DPRINTF(0, ("Got unfinished fp instruction exception\n"));
	break;

    case FSR_TT_UNIMP:
	DPRINTF(0, ("Got unimplemented fp instruction exception\n"));
	break;

    case FSR_TT_SEQERR:
	panic("Floating point sequence error");
	break;

    default:
	DPRINTF(0, ("Got unknown floating point instruction exception\n"));
	putsig(curthread, (signum) EXC_FPE);
	swtrap((signum) EXC_FPE, framep);
	return;
    }
}

#ifdef USER_INTERRUPTS
#include "fast_copy.h"
#endif

/*
 * callcatcher() (ENTRY POINT) -- a very bad name for the routine that makes
 * the given threadstate for the current thread return to the given signal
 * vector. We do this by inserting a register window into the chain (at least
 * on the stack) below the last user window (pointed to by framep->tu_fp).
 * We must:
 *    	umap a new user register window (newsp)
 *	memmove the inputs from the ustate into the new frame
 *	insert the new window into the chain
 *	fill in the input registers of the ustate (since these are the
 *	  output registers of the first user window
 */
callcatcher( signo, sigvec, framep )
long signo;
sig_vector *sigvec;
thread_ustate *framep;
{
    struct catchframe {
	struct stack_frame c_sf; 
	thread_ustate c_fault;
    } *newsp;
    int userfp = framep->tu_fp - sizeof( *newsp );

    DPRINTF( 1, ("callcatcher(%d, %x, %x)\n", signo, sigvec, framep));
#ifndef USER_INTERRUPTS
    fast_flush_windows();
#endif

    newsp = (struct catchframe *)
	umap( curthread, (vir_bytes) userfp, (vir_bytes) sizeof( *newsp ), 1 );
    DPRINTF( 1, ("tu_fp=%x, usersp=%x, newsp=%x\n", framep->tu_fp, userfp, newsp));
    if ( newsp == 0 ) return( 0 );

#ifndef USER_INTERRUPTS
    (void) memmove( (_VOIDSTAR) &newsp->c_fault, (_VOIDSTAR) framep, 
						sizeof( *framep ));
    (void) memset( (_VOIDSTAR) &newsp->c_sf, 0, sizeof(newsp->c_sf) );
#else
    fast_copy( (unsigned short *) framep, (unsigned short *) &newsp->c_fault,
	       sizeof( *framep ) / 2);
    /* clearing the new frame is not absolutely neccessary */
#endif

    framep->tu_in[ 0 ] = signo;
    framep->tu_in[ 1 ] = userfp + sizeof( newsp->c_sf );
    framep->tu_in[ 2 ] = sigvec->sv_arg3;
    framep->tu_in[ 3 ] = sigvec->sv_arg4;

    framep->tu_fp = userfp;
    framep->tu_retaddr = -1;

    framep->tu_pc = sigvec->sv_pc;
    framep->tu_npc = MAKE_NPC( sigvec->sv_pc );

    return( 1 );
}

#endif	/* NOPROC */

/*
 * These are what the arguments to a trap handler look like. This routine
 * is put into all unclaimed TBR fields, to catch spurious interrupts and
 * their ilk. Now it just panic()s.
 */
/*ARGSUSED*/
void
trap( reason, framep, pc, psr, pid )
int reason;				/* Trap type (from TBR) */
thread_ustate *framep;			/* Frame on kernel stack */
int pc;					/* Address of trapping instruction */
int psr;				/* Original PSR (right after trap) */
int pid;				/* Process ID number */
{
    DPRINTF(0, ( "trap: reason %x, framep %x, pc %x, psr %x, pid %x\n",
	  reason, framep, pc, psr, pid ));

    if ( USERMODE( framep->tu_psr ))
	puttrap( reason );
    else
	panic( "trap: reason %x, framep %x, pc %x, psr %x, pid %x\n",
		  reason, framep, pc, psr, pid );
}

/*
 * probe() (ENTRY POINT) -- Check if address is readable.
 * wprobe() (ENTRY POINT) -- Check if address is writable.
 * These return one if address is okay, zero for error.
 *
 * The width parameter says how many bytes wide the access should be.
 * Thus, 1 = byte, 2 = half-word, 4 = word, 8 = double word.  Other values
 * and it will also return 0.
 * The third parameter to sparc_probe is 0 for read, 1 for write
 */
probe( addr, width )
vir_bytes addr;
int width;
{
    return( sparc_probe( addr, width, 0 ));
}

wprobe( addr, width )
vir_bytes addr;
int width;
{
    return( sparc_probe( addr, width, 1 ));
}


/*
 * setvec() (DEVICE ENTRY POINT) -- make the interrupt or fault whose 'tt'
 * field is given in vecno, magically end up at the given routine. This
 * routine will get the arguments:
 *	handler( int ttfield, struct stack_frame *sp, int pc, int psr );
 * We do not handle vector chaining, althought we eventually should.
 */
setvec( vecno, routine )
unsigned vecno;
void (*routine)();
{
    int oldints;

    compare(vecno, <, 256);
    trap_function[ vecno ] = routine;
    oldints = sparc_disable();
    trap_table[ vecno ] = trap_template;
    (void) setints( oldints );

    DPRINTF(1, ("setvec(0x%x, 0x%x)\n", vecno, routine));

    return vecno;
}

/*
 * setup_interrupt() (DEVICE ENTRY POINT) -- called from device drivers to
 * allow us to initialize the given interrupt to point to the given routine.
 */
setup_interrupt( info, routine )
intrinfo *info;
void (*routine)();
{
    return setvec( info->ii_vector, routine );
}

/*
 * inittrap() (ENTRY POINT) -- perform any trap and fault related
 * initialzation. We start by setting up the trap table, copying the
 * one the PROM was using and then making any modification we want to it.
 * This ensures that unclaimed or stray interrupts will go to the PROM,
 * allowing such useful things as the debugger and the console handler to
 * operate correctly. Our "as.S" file contains the templates for generic
 * traps, as well as specific ones for the overflow and underflow handlers.
 * We go ahead and claim the two vectors that need special attention, and
 * other portions of the code call setvec() to hook interrupts they need.
 * We also need to set the interrupts to a nice calm state, and then lower
 * the processer interrupt level in the PSR.
 */
void
inittrap() {
    unsigned int i;
    struct trap_vector *tbr;
    struct trap_vector *oldtbr;

    disable();
    initmmearly();

    tbr = trap_table;
    oldtbr = (struct trap_vector *) ( ~TBR_MASK & (int) sparc_gettbr());
    (void) memmove( (_VOIDSTAR) tbr, (_VOIDSTAR) oldtbr, NUM_TRAPV * SIZE_TRAPV );

    tbr[ TRAPV_WND_OVER ] = trap_overflow_template;
    tbr[ TRAPV_WND_UNDER ] = trap_underflow_template;

    sparc_settbr( tbr );		/* Make traps use our table */

    for ( i = 0; i < NUM_TRAPV; i++ ) {
	if ( i == 0xFF ) continue;	/* PROM debugger */
	if ( i == INT_SERIAL ) continue;/* PROM keyboard */
	if ( i == TRAPV_WND_OVER ) continue;
	if ( i == TRAPV_WND_UNDER ) continue;

	setvec( i, trap );		/* Stray goes to trap() */
    }

#ifndef NOPROC
    setvec( TRAPV_TRAPBASE + TRAPV_SYSCALL, sparc_syscall );
    setvec( TRAPV_FP_DISB, fp_disabled );
    setvec( TRAPV_FP_EXPT, fp_exception );
#endif

#ifndef NDEBUG
    if ( sparc_teststack( 0, 1, 2, 3, 4, 5 )) panic( "teststack1" );
#ifndef NOPROC
    /* badsysc_test( machine.mi_nwindows ); */
#endif
#endif	/* !NDEBUG */
}

#ifndef NOPROC
#ifndef NDEBUG
extern void syscall_test();

/*ARGSUSED*/
static
fake(n) {
}

badsysc_test( n )
int n;
{
    if ( n == 0 ) syscall_test();
    else {
	badsysc_test( n - 1 );
	fake(n);	/* No tail recursion */
    }
}
#endif	/* !NDEBUG */
#endif

/*
 * stacktrace() (ENTRY POINT) -- hunt through the kernel finding and
 * printing out stack frames. We get the frame pointer from assembly, and
 * just whiffle down the chain, mapping frames into kernel address space,
 * until we hit an obviously invalid stack pointer.
 */
void
stacktrace _ARGS(( void ))
{
    struct stack_frame *uvsp, *kvsp, *sparc_getfp();
    char *cp;
    int i;
    static int recursive;

    struct callinsn {
	unsigned int ci_op: 2;
	unsigned int ci_disp: 30;
    } *cip;

    if (recursive)
    {
	printf("recursive stacktrace\n");
	return;
    }
    recursive = 1;

    fast_flush_windows();
    uvsp = sparc_getfp();

    cp = "stacktrace too deep";
    for (i = 0; i < 100; i++) {
	if ( (uint32) uvsp & 3 ) {
	    cp = "stack pointer not aligned";
	    break;
	}

	if ( (uint32) uvsp >= (uint32) KERNBASE &&
			(uint32) uvsp < mmu_maxaddr ) {
	    kvsp = uvsp;
	}
	else {
#ifndef NOPROC
	    kvsp = (struct stack_frame *)
		umap( curthread, (vir_bytes) uvsp,
					    (vir_bytes) sizeof( *uvsp ), 0 );
	    if ( kvsp == 0 ) {
		cp = "umap failed";
		break;
	    }
#else
	    kvsp = 0;
	    cp = "end trace";
	    break;
#endif

	}

	if ( sparc_probe( (vir_bytes) kvsp, 0, 0 ) == 0 ) {
	    cp = "memory probe failed (low)";
	    break;
	}
	    
	if ( sparc_probe( (vir_bytes) &kvsp->sf_in[ ARCH_NUMREGS - 1 ],
		       0, 0 ) == 0 ) {
	    cp = "memory probe failed (high)";
	    break;
	}

	printf( "SP virt %08x, phys %08x::\n", uvsp, kvsp );
	if ( kvsp->sf_retaddr != 0 && kvsp->sf_retaddr != -1 ) {
	    if ((unsigned) kvsp->sf_retaddr >= KERNBASE &&
			   kvsp->sf_retaddr < mmu_maxaddr)
		cip = (struct callinsn *) kvsp->sf_retaddr;
	    else
#ifndef NOPROC
		cip = (struct callinsn *) umap( curthread,
						(vir_bytes) kvsp->sf_retaddr,
						(vir_bytes) sizeof( *cip ), 0 );
#else
		cip = 0;
#endif
	    
	    if ( cip < (struct callinsn *) KERNBASE ) {
		printf( "(memory error fetching return addr insn)\n" );
	    } else {
		if ( cip->ci_op == 1 ) {
		    printf( "CALL %08x from %08x\n",
			   kvsp->sf_retaddr + ( cip->ci_disp << 2 ),
			   kvsp->sf_retaddr );
		} else {
		    printf( "XX (%08x) from %08x\n", *cip, kvsp->sf_retaddr );
		}
	    }
	} else
	    printf( "XXXX (%08x) (dead)\n", kvsp->sf_retaddr );

	printf( "%d w locals ( %08x %08x %08x %08x %08x %08x %08x %08x )\n",
	       i, kvsp->sf_local[ 0 ], kvsp->sf_local[ 1 ],
	       kvsp->sf_local[ 2 ], kvsp->sf_local[ 3 ], kvsp->sf_local[ 4 ],
	       kvsp->sf_local[ 5 ], kvsp->sf_local[ 6 ], kvsp->sf_local[ 7 ]);
	printf( "    ins    ( %08x %08x %08x %08x %08x %08x %08x %08x )\n",
	       kvsp->sf_in[ 0 ], kvsp->sf_in[ 1 ],
	       kvsp->sf_in[ 2 ], kvsp->sf_in[ 3 ], kvsp->sf_in[ 4 ],
	       kvsp->sf_in[ 5 ], kvsp->sf_in[ 6 ], kvsp->sf_in[ 7 ]);
	if ( uvsp == (struct stack_frame *) kvsp->sf_fp ) {
	    cp = "circular stack";
	    break;
	}

	uvsp = (struct stack_frame *) kvsp->sf_fp;

	if ( kvsp->sf_retaddr == 0 || kvsp->sf_retaddr == -1 ) {
	    cp = "end of ret chain";
	    break;
	}
    }
    printf( "done: %s: %08x\n", cp, uvsp );
    recursive= 0;
}

#ifdef PROFILE

static char *profile_head, *profile_tail, *profile_ptr;
static void (*profile_done) _ARGS((int res));
int prof_users; /* number of processes currently profiling */

static void
profile_do_start(milli)
long milli;
{
    prof_start_clock(milli);
    prof_users++;
}

static void
profile_do_stop()
{
    if (--prof_users == 0) {
	prof_stop_clock();
    }
}

errstat
profile_start(buffer, size, milli, done)
char *buffer;
bufsize size;
long milli;
void (*done)();
{
    profile_head = profile_ptr = buffer;
    profile_tail = buffer + size;
    profile_done = done;
    profile_do_start(milli);
    return STD_OK;
}

void
profile_stop()
{
    profile_do_stop();
}

errstat
user_prof_start(milli)
long milli;
{
    profile_do_start(milli);
    return STD_OK;
}

void
user_prof_stop()
{
    profile_do_stop();
}

#define	APPEND(x)	prof_ptr = buf_put_uint32(prof_ptr, prof_end, x);
void
profile_timer(tp, pc, psr)
thread_ustate *tp;
uint32	pc;
uint32	psr;
{
    char *		prof_ptr;
    char *		prof_end;
    struct stack_frame * sp;
    struct stack_frame * fp;

    if ( psr & PSR_PS ) {
	if (profile_ptr == NULL) {
	    /* This can happen during user profiling */
	    return;
	}

	prof_ptr = profile_ptr;
	prof_end = profile_tail;

	fast_flush_windows();
	APPEND( pc );
	sp = &tp->tu_sf;
	fp = (struct stack_frame *) sp->sf_fp;
	while ( sp != 0
	       && sp != (struct stack_frame *) -1
	       && sp->sf_retaddr != -1
	       && fp >= (struct stack_frame *) KERNBASE
	       && sp != fp ) {
	    APPEND( sp->sf_retaddr );
	    sp = fp;
	    fp = (struct stack_frame *) sp->sf_fp;
	}
	APPEND( 0 );

	if (prof_ptr == NULL) {
	    /* report filled profile buffer (ignoring truncated trace) */
	    (*profile_done)(profile_ptr - profile_head);
	    return;
	} else {
	    profile_ptr = prof_ptr;
	}
    } else {
	user_prof_tick((vir_bytes) pc);
    }
}

#endif /* PROFILE */

#ifndef NDEBUG
/*
 * sparc_teststack() -- Test the functionality of the stack, its overflow
 * and underflow handlers, and such gunk. Initial invocation should be:
 *	if ( sparc_teststack( 0, 1, 2, 3, 4, 5 )) panic( "teststack" );
 */
sparc_teststack( a, b, c, d, e, f )
int a, b, c, d, e, f;
{
    int aa = a+2, bb = b+2, cc = c+2, dd = d+2, ee = e+2;

    if (( a + 1 != b ) ||( b + 1 != c ) ||
	( c + 1 != d ) || ( d + 1 != e ) || ( e + 1 != f ))
	panic( "test1" );

    if ( a <= 4 * machine.mi_nwindows ) {
	if ( b != sparc_teststack( a+1, b+1, c+1, d+1, e+1, f+1  ))
	    panic( "test2" );
    } else fast_flush_windows();

    if (( a + 1 != b ) ||( b + 1 != c ) ||
	( c + 1 != d ) || ( d + 1 != e ) || ( e + 1 != f ))
	panic( "test3" );

    if (( aa - 1 != b ) ||( bb - 1 != c ) ||
	( cc - 1 != d ) || ( dd - 1 != e ) || ( ee - 1 != f ))
	panic( "test4" );
    return( a );
}
#endif	/* !NDEBUG */

#ifndef SMALL_KERNEL

#ifdef STATISTICS
/*
 * trap_dump() (CONFIG ENTRY POINT) -- called from the dumptab to dump any
 * trap related information we want someone else to see.
 */
trap_dump( begin, end )
char *begin;
char *end;
{
    int i;
    char *p;

    extern int trap_mapping[], trap_count[];

    p = bprintf( begin, end, "trap counts:: " );
    for ( i = 0; i < 256; i++ ) {
	if (( i & 3 ) == 0 )
	    p = bprintf( p, end, "\n" );
	p = bprintf( p, end, "\t(%03d) %8d", i, trap_count[ i ]);
    }

    p = bprintf( p, end, "\ntrap_maps: ok %d, nada %d, bad %d\n",
		    trap_mapping[ 0 ], trap_mapping[ 1 ], trap_mapping[ 2 ] );

    return p - begin;
}

#endif	/* STATISTICS */

#endif /* SMALL_KERNEL */
