/*	@(#)sesimpl.c	1.10	96/02/27 13:14:28 */
/*
 * Copyright 1994 Vrije Universiteit and Stichting Mathematisch Centrum,
 * The Netherlands.
 * For full copyright and restrictions on use see the file COPYRIGHT in
 * the top level of the Amoeba distribution.
 */

/* The session server proper.
   The server main loop is generated by AIL; this file only
   contains the implementation functions for the various requests.
*/

/* TO DO: finer locking granularity */
/* TO DO: do slow things outside locks (esp. transactions) */
/* TO DO: reorganize the code (maybe split into several files) */

#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <amtools.h>
#include <assert.h>
#include <class/sessvr.h>
#include <ajax/sigsvr.h>
#include <ajax/mymonitor.h>
#define  _POSIX_SOURCE
#include <limits.h>
#include <module/proc.h>
#include <module/rnd.h>
#include <module/tod.h>
#include <module/cap.h>
#include <exec_fndhost.h>
#include <sys/types.h>
#include <signal.h>
#include <capset.h>

#include "pipelink.h"
#include "share.h"
#include "alarm.h"
#include "devproc.h"
#include "session.h"

/* The following signals result in a core file to be dumped when a process
 * is killed explicitly (using kill() or pro_stun())).
 */
#define CORE_SIGNAL(sig)	\
	((sig) == SIGQUIT ||	\
	 (sig) == SIGILL  ||	\
	 (sig) == SIGTRAP ||	\
	 (sig) == SIGABRT ||	\
	 (sig) == SIGEMT  ||	\
	 (sig) == SIGFPE  ||	\
	 (sig) == SIGBUS  ||	\
	 (sig) == SIGSEGV ||	\
	 (sig) == SIGSYS)

extern long _sp_now;	/* time variable used by directory server */

extern void goaway();
extern void check_svr_threads();
extern errstat embalm();

extern char *capname;	/* "/dev/session" or equivalent */
extern int permanent;	/* Set if we must stay around forever */
extern port Ses_checkfield;

/* Process state */
typedef enum {
	FREE,	 	/* Unused process table slot */
	RUNNING, 	/* Normal running process */
	PARENT,  	/* Parent just after fork; until ses_parent call */
	CHILD,	 	/* Child just after fork: must tell its sessvrcap */
	NEWPROC, 	/* Proc slot created by ses_newchild */
	EXECING, 	/* Process is busy execing a new program */
	WAITING, 	/* Process is waiting for a child to die */
	CALLBACK,	/* Original owner callback */
	KILLING, 	/* Killing signal sent, but checkpt not yet received */
	DEAD, 		/* Process died, but living parent doesn't know yet */

	/*** IF YOU ADD STATES, ALSO ADD THEM TO THE MESSAGE TABLE BELOW! ***/
	
	LASTSTATE /* Sentinel value */
} state_t;

char *statemessage[] = {
	"FREE",
	"RUNNING",
	"PARENT",
	"CHILD",
	"NEWPROC",
	"EXECING",
	"WAITING",
	"CALLBACK",
	"KILLING",
	"DEAD",
	
	"[if you see this it's a bug]",
};

/* Process table */
struct {
	state_t	   state;	/* State pf process and table slot */
	int	   pid;		/* Process ID; 0 if free slot */
	int	   ppid;	/* Parent process ID; 0 if free slot */
	int	   pgrp;	/* Process group */
	int	   sigaware;	/* Signal-awareness flag */
	long	   sigignore; 	/* Signals to ignore, if not signal-aware */
	long	   sigpending;	/* Pending signals */
	long	   sigblock;	/* blocked signals, if not signal-aware */
	int	   alive;	/* For process garbage collection by sweeper */
	port	   check;	/* For protection */
	capability sigsvrcap;	/* Signal server thread, if signal-aware */
	capability owner;	/* Optional original owner */
	capability process;	/* Process capability */
	capability runsvr;	/* Optional Run server to be used with fork()*/
	capability pooldir;	/* Optional Pooldir to be used with fork() */

	/* If state == WAITING: */
	capability callback;	/* Callback when a child dies */
	int wpid;		/* Pid to wait for, or (negative) pgrp */

	/* If state == DEAD: */
	int cause;		/* Termination cause */
	long detail;		/* Corresponding detail */

	/* If state == PARENT: */
	int cpid;		/* Pid of child just forked/being forked */

	/* if state != PARENT: */
	int forkerr;		/* error code from last fork */
} proc[MAXNPROC]; /* MAXNPROC is defined in class sessvr */

/* Locking */
mutex ptmu; /* Process table mutex */
/* XXX should use locking per proctab entry */

#define FIRSTSLOT	1	/* slot 0 is unused */
#define PROC_SLOT(slot)	((slot) >= FIRSTSLOT)

/* Range for process IDs */
#define ROOTPID 1 /* Parent of orphans */
#define MINPID 2
#define MAXPID 0x7fff

/* Make sure we don't run out of pids before running out of table slots */
#if MAXNPROC >= MAXPID-MINPID
Error: there are more process table slots than possible pids!;
#endif

/* Assume a process is dead when a std_info on it fails
 * MAX_ALIVE times in a row (done by sweeper thread).
 */
#define MAX_ALIVE	3

static capability Session_proccap;

static char *
state_descr(state)
state_t state;
{
    if (((int) state >= (int) FREE) && ((int) state <= (int) DEAD)) {
	return statemessage[(int) state];
    } else {
	return "STRANGE";
    }
}

void
init_sesimpl()
{
    errstat err;

    mu_init(&ptmu);

    /* Publish my own process capability in /dev/proc first */
    if (getinfo(&Session_proccap, (process_d *)NULL, 0) < 0) {
	fatal("can't get my own process capability");
    }

    err = proc_publish(ROOTPID, 0, &Session_proccap);
    if (err != STD_OK) {
	warning("cannot publish session process cap (%s)", err_why(err));
    }
}

/* Global variable set (by find_n_lock) when any kind of activity happens.
   Regularly reset by the sweeper thread; in "-a" mode, the server exits
   when the processes table is empty and nothing happens for a minute. */

static int any_activity = 0;

/* Find a process with given pid.  Return -1 if none.
   Do not use to find a free slot. */

static int
findpid(pid)
	int pid;
{
	int i;
	
	if (pid < MINPID || pid > MAXPID) {
		MON_NUMEVENT("findpid: pid out of range", pid);
		return -1;
	}
	for (i = FIRSTSLOT; i < MAXNPROC; ++i) {
		if (proc[i].pid == pid && proc[i].state != FREE)
			return i;
	}
	return -1;
}

/* Find process slot and lock proc table; interface used by AIL main
   loop.  Returns either positive process slot number, or zero (request
   for the session super cap), or negative (if the pid was not valid or
   if the check field was wrong). */

errstat
find_n_lock(p, pslot)
	private *p;
	int *pslot;
{
	rights_bits rights;
	int pid;
	int slot;
	
	any_activity = 1;
	
	pid = prv_number(p);
	if (pid == 0) {
		slot = 0;
		if (prv_decode(p, &rights, &Ses_checkfield) != 0) {
		    warning("prv_decode failed for session supercap");
		    return STD_CAPBAD;
		}
	}
	else {
		if ((slot = findpid(pid)) < 0) {
		    MON_NUMEVENT("find_n_lock: not found", pid);
		    return STD_CAPBAD;
		}
		if (prv_decode(p, &rights, &proc[slot].check) != 0) {
		    /* someone is trying to fool us? */
		    warning("prv_decode failed for pid %d (slot %d)",
			    pid, slot);
		    return STD_CAPBAD;
		}
	}


	/* XXX experiment: fail if the mu_trylock fails.
	   Assumption: this only happens if we catch a transaction
	   signal and in that case the client is not interested.
	   XXX debugging the session server makes this untrue. */
	if (mu_trylock(&ptmu, (interval)-1) < 0)
	    return STD_INTR;

	*pslot = slot;
	return STD_OK;
}

/* Corresponding routine to cleanup and unlock.  Will only be called
   when find_n_lock() has returned >= 0. */

/*ARGSUSED*/
void
cleanup_unlock(i1)
	int i1;
{
	mu_unlock(&ptmu);
}

static int
has_rights(prv, slot, required)
private    *prv;
int         slot;
rights_bits required;
{
    /*
     * Most rights checking code is generated by Ail, but a few
     * commands are inherited from other classes, and for those
     * we have to do it ourselves.
     */
    port       *check;
    rights_bits rights;

    if (slot == 0) {
	check = &Ses_checkfield;
    } else if (PROC_SLOT(slot)) {
	check = &proc[slot].check;
    } else {
	return 0;
    }

    if (prv_decode(prv, &rights, check) != 0) {
	/* should not happen, it was already checked in find_n_lock */
	warning("prv_decode failed in fetch_rights");
        return 0;
    }

    return ((rights & required) == required);
}

#define BUSY_STATE(s)	((s) == RUNNING || (s) == PARENT || \
			 (s) == CHILD   || (s) == NEWPROC)

/* Variable nprocs_busy contains the number of processes being in a BUSY_STATE.
 * It is used to (dynamically) determine number of server threads required.
 */
int nprocs_busy = 0;

/* Change state of a process, and update statistics */
static void
set_state(slot, new_state)
	int slot;
	state_t new_state;
{
	state_t old_state = proc[slot].state;

	if (BUSY_STATE(old_state)) {
		nprocs_busy--;
	}
	if (BUSY_STATE(new_state)) {
		nprocs_busy++;
	}

	proc[slot].state = new_state;
}

/* Find and initialize a new process slot.  Return -1 if proc table full. */

static int
newslot(state, pid, ppid, pgrp)
	state_t state;
	int pid, ppid, pgrp;
{
	int i;
	
	if (pid < MINPID || pid > MAXPID) {
		warning("newslot: bad pid %d", pid);
		return -1;
	}
	/* Silly compiler doesn't allow <> on enums */
	assert((int)state >= (int)FREE && (int)state <= (int)LASTSTATE);
	for (i = FIRSTSLOT; i < MAXNPROC; ++i) {
		if (proc[i].state == FREE) {
			set_state(i, state);
			proc[i].pid = pid;
			proc[i].ppid = ppid;
			proc[i].pgrp = pgrp;
			proc[i].sigaware = 0;
			proc[i].sigignore = 0L;
			proc[i].sigpending = 0L;
			proc[i].sigblock = 0L;
			proc[i].alive = MAX_ALIVE;
			uniqport(&proc[i].check);
			CAPZERO(&proc[i].owner);
			CAPZERO(&proc[i].process);
			CAPZERO(&proc[i].runsvr);
			CAPZERO(&proc[i].pooldir);
			/* The following two aren't really necessary... */
			CAPZERO(&proc[i].sigsvrcap);
			CAPZERO(&proc[i].callback);
			proc[i].wpid = 0;
			proc[i].forkerr = STD_OK;
			return i;
		}
	}
	MON_EVENT("newslot: PROCESS TABLE FULL");
	return -1;
}

/* Free a process slot */

static void
freeslot(slot)
	int slot;
{
	set_state(slot, FREE);
}

/* Find the next child of a process, with index > i.  Return -1 if none.
   Idiom to iterate over p's children:
	int j = -1;
	while ((j = nextchild(pid, j)) >= 0) {
		<do something to proc[j]>
	}
*/

static int
nextchild(pid, slot)
	int pid;
	int slot;
{
	for (++slot; slot < MAXNPROC; ++slot) {
		if (proc[slot].ppid == pid && proc[slot].state != FREE)
			return slot;
	}
	return -1;
}

/* Generate a new process ID */

static int
makenewpid()
{
	static int nextpid = MINPID;
	
	MON_EVENT("makenewpid");
	/* Since there are more possible pids than process table slots,
	   this loop will terminate */
	for (;; ++nextpid) {
		if (nextpid > MAXPID)
			nextpid = MINPID;
		if (findpid(nextpid) < 0)
			return nextpid++;
	}
}

/* Build an owner capability for the given pid.
   (The header is used to get the port.) */

static errstat
makeownercap(h, owner, slot, pid, func)
	header *h;
	/*out*/ capability *owner;
	int slot;
	int pid;
	char *func;
{
	MON_EVENT("makeownercap");
	if (slot < 0) {
	    if ((slot = findpid(pid)) < 0) {
		warning("%s: makeownercap: pid %d not found", func, pid);
		return STD_SYSERR;
	    }
	}
	if (proc[slot].pid != pid) {
	    warning("%s: makeownercap: slot %d contains pid %d, not %d",
		    func, slot, proc[slot].pid, pid);
	    return STD_SYSERR;
	}

	owner->cap_port = h->h_port;
	if (prv_encode(&owner->cap_priv, (objnum) pid,
		       PRV_ALL_RIGHTS, &proc[slot].check) != 0)
	{
	    warning("%s: makeownercap: prv_encode failed", func);
	    return STD_SYSERR;
	}
	return STD_OK;
}

static void deliver_pending_signals(/* i */);
static errstat storeproc(/* i, replace */);

static void
wrong_state(func, pid, actual, required)
char   *func;
int     pid;
state_t actual;
state_t required;
{
    warning("%s: pid %d: state %s instead of %s",
	    func, pid, state_descr(actual), state_descr(required));
}


errstat
impl_ses_init(h, slot, self, owner_ret)
	header *h;
	/*in*/	capability *self;
	/*out*/	capability *owner_ret;
{
	int pid;
	errstat err;
	
	MON_EVENT("ses_init");
	if (PROC_SLOT(slot)) {
		pid = proc[slot].pid;
		MON_NUMEVENT("ses_init: re-attach pid", pid);
		if (proc[slot].state == EXECING) {
			MON_EVENT("ses_init: (make execing process running)");
			proc[slot].sigaware = 0;
			/* .sigignore has been set by ses_preexec */
			set_state(slot, RUNNING);
		}
		else if (proc[slot].state == NEWPROC) {
			MON_EVENT("ses_init: (make newproc running)");
			set_state(slot, RUNNING);
		}
		else if (proc[slot].state != RUNNING) {
			wrong_state("ses_init", pid, proc[slot].state,
				    RUNNING);
			return STD_NOTNOW;
		}
		else {
			MON_EVENT("ses_init: (already marked running)");
		}
	}
	else {
		if (slot != 0) {
		    return STD_CAPBAD;
		}

		/* A process started completely outside us wants to join
		   the game.  Assign it a pid and a process slot. */
		pid = makenewpid();
		if ((slot = newslot(RUNNING, pid, ROOTPID, pid)) < 0) {
			warning("ses_init: process table full");
			return STD_NOSPACE;
		}
		
		/* Get the current owner (using *owner_ret as a temp
		   variable) and store it in proc[slot].owner, unless it is
		   ourselves.  When the process eventually dies, the
		   original owner will be notified. */
		err = pro_getowner(self, owner_ret);
		if (err != STD_OK) {
			warning("cannot get owner of pid %d (%s)",
				pid, err_why(err));
		}
		else {
			if (!PORTCMP(&owner_ret->cap_port, &h->h_port))
				proc[slot].owner = *owner_ret;
		}
		
		/* Change the owner to ourselves, so we will receive
		   a checkpoint when it dies. */
		err = makeownercap(h, owner_ret, slot, pid, "ses_init");
		if (err != STD_OK) {
			warning("cannot make ownercap for pid %d (%s)",
				pid, err_why(err));
			return err;
		}
		else {
			err = pro_setowner(self, owner_ret);
			if (err != STD_OK) {
				warning("cannot set owner of pid %d (%s)",
					pid, err_why(err));
			}
		}
	}
	proc[slot].process = *self;
	(void) storeproc(slot, 0);
	deliver_pending_signals(slot);
	return makeownercap(h, owner_ret, slot, pid, "ses_init");
}

/*ARGSUSED*/
errstat
impl_ses_preexec(h, slot, sigignore, sigblock, sigpending)
	header *h;
	/*in*/	long sigignore;
	/*in*/	long sigblock;
	/*in*/	long sigpending;
{
	int pid;
	
	if (!PROC_SLOT(slot))
		return STD_CAPBAD;
	pid = proc[slot].pid;
	MON_NUMEVENT("ses_preexec", pid);
	if (proc[slot].state == KILLING) {
		/* The process was killed just before it was able to install
		 * a signal handler
		 */
		return STD_NOTNOW;
	} else if (proc[slot].state != RUNNING) {
		wrong_state("ses_preexec", pid, proc[slot].state, RUNNING);
		return STD_NOTNOW;
	}
	set_state(slot, EXECING);
	if (proc[slot].sigaware) {
		proc[slot].sigignore = sigignore;
		proc[slot].sigblock = sigblock;
		proc[slot].sigpending = sigpending;
	}
	return STD_OK;
} 
 
/* Backward compatibility: */
errstat
impl_ses_old_preexec(h, slot, sigignore)
	header *h;
	/*in*/	long sigignore;
{
	return impl_ses_preexec(h, slot, sigignore, 0L, 0L);
}

/*ARGSUSED*/
errstat
impl_ses_execbad(h, slot)
	header *h;
{
	int pid;
	
	if (!PROC_SLOT(slot))
		return STD_CAPBAD;
	pid = proc[slot].pid;
	MON_NUMEVENT("ses_execbad", pid);
	if (proc[slot].state == NEWPROC) {
		MON_NUMEVENT("ses_execbad: abort newproc, pid", pid);
		ob_allunshare(pid);
		freeslot(slot);
		return STD_OK;
	}
	if (proc[slot].state != EXECING) {
		wrong_state("ses_execbad", pid, proc[slot].state, EXECING);
		return STD_NOTNOW;
	}
	set_state(slot, RUNNING);
	deliver_pending_signals(slot);
	return STD_OK;
}

/*ARGSUSED*/
errstat
impl_ses_execok(h, slot, newprocess)
	header *h;
	/*in*/	capability *newprocess;
{
	int pid;
	
	if (!PROC_SLOT(slot))
		return STD_CAPBAD;
	pid = proc[slot].pid;
	
	/* NB: Errors from this function need not be real errors; the
	   execing program may be scheduled to execute the ses_execok
	   long after the new process has started executing.
	   TO DO: This should be fixed somehow. */
	
	MON_NUMEVENT("ses_execok", pid);
	if (proc[slot].state != EXECING && proc[slot].state != NEWPROC) {
		MON_EVENT("ses_execok: (process already running)");
		return STD_OK;
	}
	set_state(slot, RUNNING);
	proc[slot].sigaware = 0;
	proc[slot].process = *newprocess;
	(void) storeproc(slot, 1);
	deliver_pending_signals(slot);
	return STD_OK;
}

static int forkit(/* slot, pd, owner, process_ret */);

static errstat
r_fork(h, slot, pd)
	header *h;
	process_d *pd;
{
	capability owner;
	errstat err;
	int pid, cpid;
	int j;
	unsigned k;
	
	pid = proc[slot].pid;
	MON_NUMEVENT("r_fork", pid);
	if (proc[slot].state != RUNNING) {
		wrong_state("fork", pid, proc[slot].state, RUNNING);
		proc[slot].forkerr = STD_NOTNOW;
		return STD_NOTNOW;
	}
	if ((j = newslot(CHILD, cpid = makenewpid(), pid, proc[slot].pgrp)) < 0) {
		warning("fork: pid %d: process table full", pid);
		proc[slot].forkerr = STD_NOSPACE;
		return STD_NOSPACE;
	}
	ob_allshare(pid, cpid); /* Child inherits all shared objects */
	if ((err = makeownercap(h, &owner, j, cpid, "fork")) != STD_OK) {
		return err;
	}
	for (k = 0; ;) {
		errstat err;
		err = forkit(slot, pd, &owner, &proc[j].process);
		if (err == STD_OK)
			break;
		MON_EVENT("r_fork: no child started yet");
		if (++k > 5) {
			MON_EVENT("r_fork: too many retries, give up");
			ob_allunshare(cpid);
			freeslot(j);
			proc[slot].forkerr = err;
			return err;
		}
		MON_NUMEVENT("r_fork: try again after sleep", k);
		(void) sleep(k);
	}
	set_state(slot, PARENT);
	proc[slot].cpid = cpid;
	(void) storeproc(j, 0);
	check_svr_threads();		/* may have to start one extra */
	proc[slot].forkerr = STD_OK;	/* clear error flag */
	return STD_OK;
}

/* Fork a process, giving it a new default owner */

static int
forkit(slot, pd, owner, process_ret)
	int slot;
	process_d *pd;
	/*in*/	capability *owner;
	/*out*/	capability *process_ret;
{
	capability  poolprocessor, saveowner;
	capability *runsvr, *pooldir;
	char	    hostbuf[PD_HOSTSIZE];
	int         pd_index, i;
	segment_d  *sd;
	errstat     err;
	
	MON_EVENT("forkit");

	/* determine run server poolcap to use */
	if (NULLPORT(&proc[slot].runsvr.cap_port)) {
		runsvr = NULL;			/* default of sessvr itself */
	} else {
		runsvr = &proc[slot].runsvr;	/* take the one specified */
	}

	/* determine pool directory to fall back on */
	if (NULLPORT(&proc[slot].pooldir.cap_port)) {
		pooldir = NULL;			/* default of sessvr itself */
	} else {
		pooldir = &proc[slot].pooldir;	/* take the one specified */
	}

	err = exec_multi_findhost(runsvr, pooldir,
				  &pd, 1, &pd_index, &poolprocessor, hostbuf);
	if (err != STD_OK) {
		warning("cannot find host to fork pid %d (%s)",
			proc[slot].pid, err_why(err));
		return err;
	}
	MON_EVENT("forkit: exec_findhost OK");
	
	/* Take away MAP_AND_DESTROY flags from segments */
	for (i = 0, sd = PD_SD(pd); i < pd->pd_nseg; ++i, ++sd) {
		sd->sd_type &= ~MAP_AND_DESTROY;
	}
	
	/* Set new owner capability (must be restored before returning) */
	saveowner = pd->pd_owner;
	pd->pd_owner = *owner;
	
	err = pro_exec(&poolprocessor, pd, process_ret);
	if (err != STD_OK) {
		/* the process server returns STD_NOSPACE when out of memory */
		if (err == STD_NOSPACE) err = STD_NOMEM;
		warning("pid %d: cannot start child (%s)",
			proc[slot].pid, err_why(err));
	}
	else {
		MON_EVENT("forkit: successful fork");
		(void) pro_setcomment(process_ret, "(forked process)");
	}
	
	pd->pd_owner = saveowner;
	return err;
}

/*ARGSUSED*/
errstat
impl_ses_parent(h, slot, cpid_ret)
	header *h;
	/*out*/	int *cpid_ret;
{
	int pid;
	
	if (!PROC_SLOT(slot))
		return STD_CAPBAD;
	pid = proc[slot].pid;
	MON_NUMEVENT("ses_parent", pid);
	if (proc[slot].state != PARENT) {
		wrong_state("ses_parent", pid, proc[slot].state, PARENT);
		/* This also happens after a failed fork... */
		if (proc[slot].forkerr == STD_OK)
			return STD_ARGBAD;
		else
			return proc[slot].forkerr;
	}
	*cpid_ret = proc[slot].cpid;
	set_state(slot, RUNNING);
	deliver_pending_signals(slot);
	return STD_OK;
}

/*ARGSUSED*/
errstat
impl_ses_child(h, slot, sigsvrcap)
	header *h;
	/*in*/	capability *sigsvrcap;
{
	int pid;
	
	if (!PROC_SLOT(slot))
		return STD_CAPBAD;
	pid = proc[slot].pid;
	MON_NUMEVENT("ses_child", pid);
	if (proc[slot].state != CHILD) {
		wrong_state("ses_child", pid, proc[slot].state, CHILD);
		return STD_ARGBAD;
	}
	proc[slot].sigsvrcap = *sigsvrcap;
	set_state(slot, RUNNING);
	deliver_pending_signals(slot);
	return STD_OK;
}

/*ARGSUSED*/
errstat
impl_ses_runsvr(h, slot, runsvr, pooldir)
	header *h;
	int     slot;
	/*in*/	capability *runsvr;
	/*in*/	capability *pooldir;
{
	if (!PROC_SLOT(slot))
		return STD_CAPBAD;
	MON_NUMEVENT("ses_runsvr", proc[slot].pid);
	proc[slot].runsvr = *runsvr;
	proc[slot].pooldir = *pooldir;
	return STD_OK;
}

/*ARGSUSED*/
errstat
impl_ses_sigaware(h, slot, sigsvrcap, sigignore_ret, sigblock_ret, sigpending_ret)
	header *h;
	/*in*/	capability *sigsvrcap;
	/*out*/	long *sigignore_ret;
	/*out*/	long *sigblock_ret;
	/*out*/	long *sigpending_ret;
{
	int pid;
	
	if (!PROC_SLOT(slot))
		return STD_CAPBAD;
	pid = proc[slot].pid;
	MON_NUMEVENT("ses_sigaware", pid);
	if (proc[slot].state != RUNNING) {
		wrong_state("ses_sigaware", pid, proc[slot].state, RUNNING);
		return STD_NOTNOW;
	}
	if (proc[slot].sigaware) {
		MON_EVENT("ses_sigaware: (already signal aware)");
	}
	*sigignore_ret = proc[slot].sigignore;
	*sigpending_ret = proc[slot].sigpending;
	*sigblock_ret = proc[slot].sigblock;
	proc[slot].sigaware = 1;
	proc[slot].sigignore = 0L;
	proc[slot].sigblock = 0L;
	proc[slot].sigpending = 0L;
	proc[slot].sigsvrcap = *sigsvrcap;
	/* deliver_pending_signals(slot); done */
	return STD_OK;
}

/* Backward compatibility */
errstat
impl_ses_old_sigaware(h, slot, sigsvrcap, sigignore_ret)
	header *h;
	/*in*/	capability *sigsvrcap;
	/*out*/	long *sigignore_ret;
{
	long dummy;

	return impl_ses_sigaware(h, slot, sigsvrcap, sigignore_ret,
				 &dummy, &dummy);
}

static int
waitingfor(wpid, j)
	int wpid;
	int j;
{
	return wpid == -1 || wpid > 0 && proc[j].pid == wpid ||
					wpid < -1 && proc[j].pgrp == -wpid;
}

static void statistics(/* h */);

errstat
impl_ses_waitpid(h, slot, pid_ret, cause_ret, detail_ret, callback)
	header *h;
	/*io*/	int *pid_ret;
	/*out*/	int *cause_ret;
	/*out*/	long *detail_ret;
	/*in*/	capability *callback;
{
	int wpid;
	int mypid;
	int j;
	int any;
	
	if (!PROC_SLOT(slot))
		return STD_CAPBAD;
	mypid = proc[slot].pid;
	MON_NUMEVENT("ses_waitpid", mypid);
	if (proc[slot].state != RUNNING) {
		wrong_state("ses_waitpid", mypid, proc[slot].state, RUNNING);
		return STD_NOTNOW;
	}
	wpid = (short) *pid_ret; /* XXX Compensate AIL bug */
	if (wpid == 0)
		wpid = -proc[slot].pgrp;
	any = 0;
	j = -1;
	while ((j = nextchild(mypid, j)) >= 0) {
		if (waitingfor(wpid, j)) {
			any = 1;
			if (proc[j].state == DEAD)
				break;
		}
	}
	if (!any) {
		MON_EVENT("ses_waitpid: no children");
		*pid_ret = -1;
	}
	else if (j < 0) {
		MON_EVENT("ses_waitpid: no children died yet");
		*pid_ret = 0;
		if (!NULLPORT(&callback->cap_port)) {
			MON_EVENT("ses_waitpid: installing callback");
			proc[slot].callback = *callback;
			proc[slot].wpid = wpid;
			set_state(slot, WAITING);
		}
		else {
			MON_EVENT("ses_waitpid: no callback");
		}
	}
	else {
		MON_EVENT("ses_waitpid: reporting child status");
		*pid_ret = proc[j].pid;
		*cause_ret = proc[j].cause;
		*detail_ret = proc[j].detail;
		/* Free the child's process table slot */
		freeslot(j);
		/* Clear the parent's callback capability */
		CAPZERO(&proc[slot].callback);
	}
	statistics(h);
	return STD_OK;
}

static errstat kill_all_but(/* pid, sig */);
static errstat kill_group(/* pgrp, sig */);
static errstat kill_proc(/* slot, sig */);
static errstat deliver_signal(/* slot, sig */);

/*ARGSUSED*/
errstat
impl_ses_kill(h, slot, victpid, sig)
	header *h;
	/*in*/	int victpid;
	/*in*/	int sig;
{
	int mypid;
	int j;
	
	if (!PROC_SLOT(slot))
		return STD_CAPBAD;
	mypid = proc[slot].pid;
	victpid = (short) victpid; /* XXX Compensate AIL bug */
	MON_NUMEVENT("ses_kill victim", victpid);
	if (sig < 0 || sig > 32 ||
			(sig != 0 && (_SIGMASK(sig) & _GOODSIGMASK) == 0)) {
		MON_NUMEVENT("ses_kill: bad signal number", sig);
		return STD_ARGBAD;
	}
	if (victpid == 0)
		return kill_group(proc[slot].pgrp, sig);
	if (victpid == -1)
		return kill_all_but(mypid, sig);
	if (victpid < 0)
		return kill_group(-victpid, sig);
	if ((j = findpid(victpid)) < 0) {
		MON_NUMEVENT("ses_kill: victim pid not found", victpid);
		return STD_NOTFOUND;
	}
	return kill_proc(j, sig);
}

errstat
ses_signal_pid(victpid, sig)
	int victpid;
	int sig;
{
	/* Used by the alarm module */
	int slot;

	if ((slot = findpid(victpid)) < 0) {
		return STD_NOTFOUND;
	} else {
		return kill_proc(slot, sig);
	}
}

static errstat
kill_all_but(pid, sig)
	int pid;
	int sig;
{
	int slot;
	int ret;
	
	MON_NUMEVENT("kill_all_but", pid);
	ret = STD_NOTFOUND;
	for (slot = FIRSTSLOT; slot < MAXNPROC; ++slot) {
		if (proc[slot].state != FREE && proc[slot].pid != pid)
			if (kill_proc(slot, sig) == STD_OK)
				ret = STD_OK;
	}
	return ret;
}

static errstat
kill_group(pgrp, sig)
	int pgrp;
	int sig;
{
	int slot;
	int ret;
	
	MON_NUMEVENT("kill_group", pgrp);
	ret = STD_NOTFOUND;
	for (slot = FIRSTSLOT; slot < MAXNPROC; ++slot) {
		if (proc[slot].pgrp == pgrp && proc[slot].state != FREE)
			if (kill_proc(slot, sig) == STD_OK)
				ret = STD_OK;
	}
	return ret;
}

static errstat
kill_proc(slot, sig)
	int slot;
	int sig;
{
	MON_NUMEVENT("kill_proc", proc[slot].pid);
	if (sig == 0 ||
			sig != SIGKILL && !proc[slot].sigaware &&
			(proc[slot].sigignore & sigmask(sig)) != 0)
		return STD_OK;
	if (proc[slot].state == RUNNING || proc[slot].state == WAITING) {
		(void) deliver_signal(slot, sig);
		return STD_OK;
	}
	MON_EVENT("kill_proc: save pending signal");
	proc[slot].sigpending |= sigmask(slot);
	return STD_OK;
}

static void
deliver_pending_signals(slot)
	int slot;
{
	long sigpending;
	int sig;
	
	if ((sigpending = proc[slot].sigpending) == 0)
		return;
	MON_NUMEVENT("deliver_pending_signals", proc[slot].pid);
	if ((sigpending & sigmask(SIGKILL)) != 0)
		(void) deliver_signal(slot, SIGKILL);
	else {
		for (sig = 1; sig < NSIG; ++sig, sigpending >>= 1) {
			if ((proc[slot].sigpending & sigmask(sig)) != 0
			&&  (proc[slot].sigblock & sigmask(sig)) == 0)
			{
				(void) deliver_signal(slot, sig);
				proc[slot].sigpending &= ~sigmask(sig);
			}
		}
	}
}

static long sig_sendsig(/* cap, sig */);
static void fake_kill(/* slot */);
static void cleanup(/* slot, h */);
static int  sendcheckpoint(/* pid, cap, h, pd, pdlen, pdlen_ret */);

static errstat
deliver_signal(slot, sig)
	int slot;
	int sig;
{
	errstat err;
	interval savetout;
	extern capability Session_pubcap;
	capability current_owner;
	
	/* Before trying to send a signal at all, first see if we are *still*
	 * the owner of process.  The owner might have changed without our
	 * knowing it (this happens, e.g., during a login session).
	 */
	savetout = timeout(2000L);
	err = pro_getowner(&proc[slot].process, &current_owner);
	(void) timeout(savetout);
	if ((err == STD_OK) &&
	    !PORTCMP(&current_owner.cap_port, &Session_pubcap.cap_port))
	{
	    MON_NUMEVENT("owner changed", proc[slot].pid);
	    return STD_OK;
	}
	
	MON_NUMEVENT("deliver_signal", proc[slot].pid);
	if (proc[slot].sigaware) {
		long errval;

		MON_EVENT("deliver_signal: trying gentle persuasion");
		err = STD_OK;
		errval = sig_sendsig(&proc[slot].sigsvrcap, sig);
		/* errval>0: handled or ignored, errval==0: default action */
		
		if (errval < 0) {
			err = (errstat) errval;
			warning("error signalling pid %d with %d (%s)",
				proc[slot].pid, sig, err_why(err));
		}
		else if (sig == SIGKILL) {
			err = STD_SYSERR; /* Force a hard kill */
		}
		else if (errval > 0) {
			MON_EVENT("deliver_signal: done");
			if (proc[slot].state == WAITING) {
				MON_EVENT("deliver_signal: interrupt waitpid");
				(void) sig_sendsig(&proc[slot].callback, sig);
				set_state(slot, RUNNING);
			}
			return STD_OK;
		}
		
		if (err != STD_OK) { /* Change policy into hard kill-only */
			proc[slot].sigaware = 0;
			proc[slot].sigignore = 0;
			proc[slot].sigblock = 0;
		}
	} else if ((proc[slot].sigblock & sigmask(sig)) != 0) {
		/* not signal aware and blocked */
		MON_NUMEVENT("deliver_signal blocked", sig);
		proc[slot].sigpending |= sigmask(sig);
		return STD_OK;
	}
	
	MON_EVENT("deliver_signal: using stun-gun");
	savetout = timeout(5000L);
	err = pro_stun(&proc[slot].process, (long) sig);
	(void) timeout(savetout);
	if (err == STD_OK) {
		MON_EVENT("deliver_signal: anesthetic applied");
		set_state(slot, KILLING);
	}
	else {
		warning("could not stun pid %d with signal %d (%s)",
			proc[slot].pid, sig, err_why(err));
		if (err == RPC_NOTFOUND || err == STD_CAPBAD) {
			warning("pid %d considered dead", proc[slot].pid);
			/* Pretend it died of a hard kill */
			fake_kill(slot);
		}
	}
	return err;
}

static void
fake_kill(slot)
	int slot;
{
	header hdr;
	capability cap;
	int pid = proc[slot].pid;
	
	if (makeownercap(&hdr, &cap, slot, pid, "fake_kill") != STD_OK) {
	    return;
	}
	hdr.h_priv = cap.cap_priv;
	hdr.h_command = PS_CHECKPOINT;
	hdr.h_extra = TERM_STUNNED;
	hdr.h_offset = SIGKILL;
	/* Tell original owner the sad news */
	if (!NULLPORT(&proc[slot].owner.cap_port))
		(void)sendcheckpoint(pid, &proc[slot].owner, &hdr,
				     NILPD, 0, (int *)NULL);
	/* Wakeup waiting parent or cleanup proc entry, etc. */
	cleanup(slot, &hdr);
}

static long
sig_sendsig(cap, sig)
	capability *cap;
	int sig;
{
	header h;
	long savetout;
	bufsize n;
	errstat err;
	
	MON_NUMEVENT("sig_sendsig, sig", sig);
	h.h_port = cap->cap_port;
	h.h_priv = cap->cap_priv;
	h.h_command = AJAX_SENDSIG;
	h.h_extra = sig;
	savetout = timeout(5000L);
	n = trans(&h, NILBUF, 0, &h, NILBUF, 0);
	(void) timeout(savetout);
	if (ERR_STATUS(n)) {
		err = ERR_CONVERT(n);
		MON_NUMEVENT("sig_sendsig: trans err", err);
		return err;
	}
	if (h.h_status != STD_OK) {
		err = ERR_CONVERT(h.h_status);
		MON_NUMEVENT("sig_sendsig: trans h_status", err);
		return err;
	}
	MON_NUMEVENT("sig_sendsig: done; trans h_offset", h.h_offset);
	return h.h_offset;
}

/*ARGSUSED*/
errstat
impl_ses_getid(h, slot, uid_ret, euid_ret, gid_ret, egid_ret)
	header *h;
	/*out*/ int *uid_ret;
	/*out*/ int *euid_ret;
	/*out*/ int *gid_ret;
	/*out*/ int *egid_ret;
{
	extern uid_t uid;
	extern gid_t gid;
 
	if (!PROC_SLOT(slot))
		return STD_CAPBAD;
 
	*uid_ret = uid;
	*euid_ret = uid;
	*gid_ret = gid;
	*egid_ret = gid;
	MON_NUMEVENT("ses_getid", uid);
	return STD_OK;
}

/*ARGSUSED*/
errstat
impl_ses_alarm(h, slot, nsec)
	header *h;
	/*in out*/	int *nsec;
{
	int pid;

	if (!PROC_SLOT(slot))
		return STD_CAPBAD;
	pid = proc[slot].pid;
	MON_NUMEVENT("ses_alarm", *nsec);
	*nsec = set_timer(pid, (unsigned int) *nsec);
	return STD_OK;
}

/*ARGSUSED*/
errstat
impl_ses_getppid(h, slot, ppid_ret)
	header *h;
	/*out*/	int *ppid_ret;
{
	int pid;
	
	if (!PROC_SLOT(slot))
		return STD_CAPBAD;
	pid = proc[slot].pid;
	MON_NUMEVENT("ses_getppid", pid);
	*ppid_ret = proc[slot].ppid;
	return STD_OK;
}

/*ARGSUSED*/
errstat
impl_ses_getpgrp(h, slot, pid, pgrp_ret)
	header *h;
	/*in*/	int pid;
	/*out*/	int *pgrp_ret;
{	
	int mypid;
	
	if (!PROC_SLOT(slot))
		return STD_CAPBAD;
	mypid = proc[slot].pid;
	MON_NUMEVENT("ses_getpgrp", mypid);
	if (pid == 0) {
		pid = mypid;
		MON_NUMEVENT("ses_getpgrp: use own pid", pid);
	}
	*pgrp_ret = proc[slot].pgrp;
	return STD_OK;
}

/*ARGSUSED*/
errstat
impl_ses_setpgrp(h, slot, pid, pgrp)
	header *h;
	/*in*/	int pid;
	/*in*/	int pgrp;
{	
	int mypid, pidslot;
	
	if (!PROC_SLOT(slot))
		return STD_CAPBAD;
	mypid = proc[slot].pid;
	MON_NUMEVENT("ses_setpgrp", mypid);

	pidslot = slot;
	if (pid == 0) {
		pid = mypid;
		MON_NUMEVENT("ses_setpgrp: use own pid", pid);
	} else if (pid != mypid) {
		pidslot = findpid(pid);
	}

	if (pgrp == 0) {
		pgrp = proc[slot].pgrp;
	}
 
	if (PROC_SLOT(pidslot)) {
		proc[pidslot].pgrp = pgrp;
		return STD_OK;
	} else {
		return STD_ARGBAD;
	}
}

static errstat linksharedfiles(/* proccap, sharedcaps, nsharedcaps, cmd */);

/*ARGSUSED*/
errstat
impl_ses_newchild(h, slot, sigignore, sigblock, sigpending,
		  newowner, sharedcaps, maxsharedcaps, nsharedcaps)
	header *h;
	/* in */	long sigignore;
	/* in */	long sigblock;
	/* in */	long sigpending;
	/* out */	capability *newowner;
	/* in */	capability sharedcaps[/*nsharedcaps*/];
	/* bound */	int maxsharedcaps;
	/* in */	int nsharedcaps;
{
	errstat err;
	int pid, cpid;
	int j;	
	
	if (!PROC_SLOT(slot))
		return STD_CAPBAD;
	pid = proc[slot].pid;
	MON_NUMEVENT("ses_newchild: pid", pid);
	j = newslot(NEWPROC, cpid = makenewpid(), pid, proc[slot].pgrp);
	if (j < 0) {
		warning("ses_newchild: pid %d: process table full", pid);
		return STD_NOSPACE;
	}
	proc[j].sigaware = 0;
	proc[j].sigignore = sigignore;
	proc[j].sigblock = sigblock;
	proc[j].sigpending = sigpending;
	if ((err = makeownercap(h, newowner, j, cpid, "new_child"))!= STD_OK) {
		return err;
	}
	err = linksharedfiles(newowner, sharedcaps, nsharedcaps, PIPE_LINK);
	if (err != STD_OK) {
		warning("ses_newchild: cannot share files of %d and %d (%s)",
			pid, cpid, err_why(err));
		/* For now we ignore this error */
	}
	check_svr_threads();	/* may have to start one extra */
	return STD_OK;
}

/* Backward compatibility: */
errstat
impl_ses_old_newchild(h, slot, sigignore, newowner, sharedcaps,
		      maxsharedcaps, nsharedcaps)
	header *h;
	/* in */	long sigignore;
	/* out */	capability *newowner;
	/* in */	capability sharedcaps[/*nsharedcaps*/];
	/* bound */	int maxsharedcaps;
	/* in */	int nsharedcaps;
{
	return impl_ses_newchild(h, slot, sigignore, 0L, 0L,
				 newowner, sharedcaps,
				 maxsharedcaps, nsharedcaps);
}

/*ARGSUSED*/
errstat
impl_ses_share(h, slot, sharedcaps, maxsharedcaps, nsharedcaps)
	header *h;
	/* in */	capability sharedcaps[/*nsharedcaps*/];
	/* bound */	int maxsharedcaps;
	/* in */	int nsharedcaps;
{
	errstat err;
	int pid;
	capability owner;
	
	if (!PROC_SLOT(slot))
		return STD_CAPBAD;
	pid = proc[slot].pid;
	MON_NUMEVENT("ses_share: pid", pid);
	if ((err = makeownercap(h, &owner, slot, pid, "ses_share"))!= STD_OK) {
		return err;
	}
	err = linksharedfiles(&owner, sharedcaps, nsharedcaps, PIPE_LINK);
	if (err != STD_OK) {
		warning("ses_share: cannot share files of %d (%s)",
			pid, err_why(err));
	}
	return err;
}

/*ARGSUSED*/
errstat
impl_ses_unshare(h, slot, sharedcaps, maxsharedcaps, nsharedcaps)
	header *h;
	/* in */	capability sharedcaps[/*nsharedcaps*/];
	/* bound */	int maxsharedcaps;
	/* in */	int nsharedcaps;
{
	errstat err;
	int pid;
	capability owner;
	
	if (!PROC_SLOT(slot))
		return STD_CAPBAD;
	pid = proc[slot].pid;
	MON_NUMEVENT("ses_unshare: pid", pid);
	if ((err = makeownercap(h, &owner, slot, pid, "unshare")) != STD_OK) {
		return err;
	}
	err = linksharedfiles(&owner, sharedcaps, nsharedcaps, PIPE_UNLINK);
	if (err != STD_OK) {
		warning("ses_unshare: cannot unshare files of %d (%s)",
			pid, err_why(err));
	}
	return err;
}

static errstat
linksharedfiles(proccap, sharedcaps, nsharedcaps, cmd)
	capability *proccap;
	capability sharedcaps[/*nsharedcaps*/];
	int nsharedcaps;
	int cmd;
{
	long savetout;
	int i;
	header h;
	bufsize n;
	errstat err, retval;
	
	/* I know, we could do this without using transactions,
	   since it will always go to the pipe server or file server
	   in the same process; but I'm in a hurry now... */
	
	retval = STD_OK;
	savetout = timeout(5000L);
	for (i = 0; i < nsharedcaps; ++i) {
		h.h_port = sharedcaps[i].cap_port;
		h.h_priv = sharedcaps[i].cap_priv;
		h.h_command = cmd;
		n = trans(&h, (char *)proccap, CAPSIZE, &h, NILBUF, 0);
		if (ERR_STATUS(n))
			err = ERR_CONVERT(n);
		else
			err = ERR_CONVERT(h.h_status);
		if (err != STD_OK)
			retval = err;
	}
	(void) timeout(savetout);
	return retval;
}

/*ARGSUSED*/
errstat
impl_ses_pipe(h, slot, read_end, write_end)
	header *h;
	/* out */	capability *read_end;
	/* out */	capability *write_end;
{
	int pid;
	int err;
	
	if (!PROC_SLOT(slot))
		return STD_CAPBAD;
	pid = proc[slot].pid;
	MON_NUMEVENT("ses_pipe: pid", pid);
	err = startpipesvr(pid, read_end, write_end);
	return err;
}

/*ARGSUSED*/
errstat
impl_ses_file(h, slot, flags, pos, size, mode, mtime, cap, dircap, name,
	      max_name, cap_ret)
	header *h;
    /*in:*/
	long flags;
	long pos;
	long size;
	int mode;
	long mtime;
	capability *cap;
	capability *dircap;
	char *name;
	int max_name;
    /*out:*/
	capability *cap_ret;
{
	int pid;
	int err;
	
	if (!PROC_SLOT(slot))
		return STD_CAPBAD;
	pid = proc[slot].pid;
	MON_NUMEVENT("ses_file: pid", pid);
	err = startfilesvr(pid,
		flags, pos, size, mode, mtime,  cap, dircap, name, cap_ret);
	return err;
}

/*ARGSUSED*/
errstat
impl_ses_seek(h, slot, filecap, offset, mode, new_off)
	header *h;
    /*in:*/
	capability *filecap;
	long offset;
	int mode;
    /*out:*/
	long *new_off;
{
	if (!PROC_SLOT(slot))
		return STD_CAPBAD;
	MON_NUMEVENT("ses_seek for pid", proc[slot].pid);
	return file_seek(filecap, offset, mode, new_off);
}

/*ARGSUSED*/
errstat
impl_ses_size(h, slot, filecap, size)
	header *h;
    /*in:*/
	capability *filecap;
    /*out:*/
	long *size;
{
	if (!PROC_SLOT(slot))
		return STD_CAPBAD;
	MON_NUMEVENT("ses_size for pid", proc[slot].pid);
	return file_size(filecap, size);
}

/*ARGSUSED*/
errstat
impl_ps_checkpoint(h, slot, pdbuf, max_pdbuf, ppdlen, cause, detail)
	header *h;
	/*in out*/	char pdbuf[/* max_pdbuf */];
	/*bound */	int max_pdbuf;
	/*in out*/	int *ppdlen;
	/*in*/		int cause;
	/*in*/		long detail;
{
	int pdlen = *ppdlen;
	process_d *pd;
	int pid;
	errstat err, retval;
	
	if (!PROC_SLOT(slot))
		return STD_CAPBAD;

	/* We still have to do rights checking in this case */
	if (!has_rights(&h->h_priv, slot, PSR_KILL))
		return STD_DENIED;

	pid = proc[slot].pid;
	MON_NUMEVENT("ps_checkpoint, pid", pid);
	if (pdlen > max_pdbuf) {
		warning("ps_checkpoint: pid %d: truncated (size %d; was %d)",
			pid, max_pdbuf, pdlen);
		/* we will probably get an unmarshalling error below,
		 * but just see how far we get.
		 */
		pdlen = max_pdbuf;
	}
	if (pdlen == 0) {
		/* XXX NOT A MISTAKE! DUMMY CKPT TELLING PROC IS LOST */
		MON_EVENT("ps_checkpoint: zero pdlen");
		return STD_ARGBAD;
	}

	retval = STD_OK;
	/* Update the process state at the end of this function even if one
	 * of the next two calls fails.  The process descriptor might be
	 * truncated because it contains too many threads.
	 */
	pd = pdmalloc(pdbuf, pdbuf+pdlen);
	if (pd == NULL) {
		warning("ps_checkpoint: pid %d: cannot allocate buffer", pid);
		/* Short pd could also cause it */
		retval = STD_NOSPACE;
	} else if (buf_get_pd(pdbuf, pdbuf+pdlen, pd) == NULL) {
		warning("ps_checkpoint: pid %d: cannot unmarshall pd, size %d",
			pid, pdlen);
		free((_VOIDSTAR) pd);
		pd = NULL;
		retval = STD_ARGBAD;
	}
	
	/* Check for special request types */
	if (cause == TERM_STUNNED && detail == R_FORK) {
		if (pd != NULL) {
		    (void) r_fork(h, slot, pd);
		    free((_VOIDSTAR) pd);
		}
		/* We must always return STD_OK here, otherwise the forking
		   process will die right away.  To determine success of
		   the fork, the forking process must make a separate call
		   to ses_parent().  The child must call ses_child() to
		   acknowledge its existence. */
		return STD_OK;
	}
	
	/* Keep some statistics */
	switch (cause) {
	case TERM_NORMAL:
		MON_NUMEVENT("ps_checkpoint: exit", detail);
		break;
	case TERM_STUNNED:
		MON_NUMEVENT("ps_checkpoint: stunned", detail);
		break;
	case TERM_EXCEPTION:
		MON_NUMEVENT("ps_checkpoint: exception", detail);
		break;
	default:
		warning("ps_checkpoint: pid %d: unknown cause %d, detail %d",
			cause, detail);
		break;
	}
	
	/* If there is an original owner (e.g., a debugger), let it
	   decide what to do; it may decide to continue the process.
	   In this case we don't ever embalm the dead body. */
	if (pd != NULL) {
	    if (!NULLPORT(&proc[slot].owner.cap_port)) {
		header h1;
		state_t savestate;

		MON_EVENT("ps_checkpoint: previous owner callback");
		h1 = *h;
		h1.h_priv = proc[slot].owner.cap_priv;
		savestate = proc[slot].state;
		set_state(slot, CALLBACK);
		mu_unlock(&ptmu); /* Since the debugger may take a while... */
		err = sendcheckpoint(pid, &proc[slot].owner,
				     &h1, pd, pdlen, &pdlen);
		if (err == STD_OK) {
			MON_EVENT("ps_checkpoint: prev owner says continue");
			if (buf_put_pd(pdbuf, pdbuf+pdlen, pd) == NULL) {
				warning("ps_checkpoint: cannot continue %d",
					pid);
				err = STD_SYSERR;
				pdlen = 0;
			}
		}
		if (err == STD_OK) {
			*ppdlen = pdlen;
			free((_VOIDSTAR) pd);
			return err;
		}
		else {
			MON_NUMEVENT("ps_checkpoint: prev owner err", err);
			mu_lock(&ptmu);
			if (proc[slot].state != CALLBACK) {
				wrong_state("ps_checkpoint", pid,
					    proc[slot].state, CALLBACK);
			}
			else
				set_state(slot, savestate);
		}
	    }
	    else if (cause == TERM_EXCEPTION ||
		     cause == TERM_STUNNED && CORE_SIGNAL(detail)) {
		/* Preserve the corpse.  If this succeeds, set bit 7
		   in the cause (in the header!) so wait() can return
		   the core dumped bit. */
		if ((err = embalm(pid, pd, pdlen)) == STD_OK) {
			h->h_extra |= 0x80;
			MON_EVENT("ps_checkpoint: process embalmed");
		}
		else {
			warning("ps_checkpoint: cannot dump core of %d (%s)",
				pid, err_why(err));
		}
	    }
	}
	
	/* TO DO: put a check here for matching process capability.
	   If mismatch, what to do depends on state:
	   if EXECING, suppose this is the new process that is ahead of
	   the old process;
	   otherwise, suppose this is either the old process that was
	   still around, or a process we never heard of.
	*/
	cleanup(slot, h);
	statistics(h);
	*ppdlen = 0; /* Send empty pd back */
	if (pd != NULL) {
	    free((_VOIDSTAR) pd);
	}
	return retval;
}

/* A process has died.
   Clean up behind it, or perhaps leave a zombie entry until the parent
   waits for it.  Entry proc[slot] is (and stays) locked.
*/

static errstat unstoreproc(/* slot */);

static void
cleanup(slot, h)
	int slot;
	header *h;
{
	int iparent, ichild;
	int pid, ppid;

	pid = proc[slot].pid;
	ppid = proc[slot].ppid;
	
	ob_allunshare(pid); /* Close any shared objects */
	
	if (proc[slot].state != NEWPROC) {
	    /* In case the state is NEWPROC, the process was not
	     * stored in the directory yet.  That happens when it
	     * switches to RUNNING.
	     */
	    (void) unstoreproc(slot); /* Remove /dev/proc/<pid> */
	}
	
	/* Note termination status */
	if (ppid == ROOTPID) {
		MON_EVENT("cleanup: an orphan died");
		freeslot(slot);
	}
	else if ((iparent = findpid(ppid)) < 0) {
		warning("cleanup pid %d: parent %d not found", pid, ppid);
		freeslot(slot);
	}
	else if (proc[iparent].state == WAITING &&
			waitingfor(proc[iparent].wpid, slot)) {
		MON_NUMEVENT("cleanup: parent callback", pid);
		set_state(iparent, RUNNING);
		(void)sendcheckpoint(pid, &proc[iparent].callback, h, NILPD, 0,
								(int *)NULL);
		freeslot(slot);
	}
	else {
		MON_NUMEVENT("cleanup: save status for parent", ppid);
		set_state(slot, DEAD);
		/* Should really take cause, detail from ps_checkpoint? */
		proc[slot].cause = h->h_extra;
		proc[slot].detail = h->h_offset;
	}
	
	/* Scavenge children */
	ichild = -1;
	while ((ichild = nextchild(pid, ichild)) >= 0) {
		if (proc[ichild].state == DEAD) {
			MON_NUMEVENT("cleanup: discard dead child",
				     proc[ichild].pid);
			freeslot(ichild);
		}
		else {
			MON_NUMEVENT("cleanup: reparent orphan to 1",
				     proc[ichild].pid);
			proc[ichild].ppid = ROOTPID;
		}
	}
}

static int
sendcheckpoint(pid, cap, h, pd, pdlen, pdlen_ret)
	int pid;
	capability *cap;
	header *h;
	process_d *pd;
	int pdlen;
	int *pdlen_ret;
{
	char *buf;
	header hdr;
	long savetout;
	errstat err;
	bufsize n;
	
	MON_EVENT("sendcheckpoint");
	hdr = *h;
	hdr.h_port = cap->cap_port;
	hdr.h_size = pdlen;
	if (pd == NULL) {
		buf = NULL;
		pdlen = 0;
	}
	else {
		buf = (char *) malloc((unsigned int) pdlen);
		if (buf == NULL) {
			warning("sendcheckpoint: pid %d: cannot alloc buffer",
				pid);
			return STD_NOSPACE;
		}
		if (buf_put_pd(buf, buf+pdlen, pd) == NULL) {
			warning("sendcheckpoint: pid %d: bad descriptor", pid);
			free((_VOIDSTAR) buf);
			return STD_SYSERR;
		}
	}
	savetout = timeout(5000L);
	n = trans(&hdr, buf, (bufsize) pdlen, &hdr, buf, (bufsize) pdlen);
	if (ERR_STATUS(n)) {
		err = ERR_CONVERT(n);
	} else {
		err = ERR_CONVERT(hdr.h_status);
	}
	(void) timeout(savetout);
	if (err != STD_OK) {
		warning("sendcheckpoint failed for pid %d (%s)",
			pid, err_why(err));
	}
	else if (pdlen == 0) {
		err = STD_OK;
	}
	else if (n != pdlen) {
		MON_NUMEVENT("sendcheckpoint: not the right size back", n);
		err = STD_DENIED;
	}
	else {
		MON_EVENT("sendcheckpoint: got checkpoint back");
		if (buf_get_pd(buf, buf+n, pd) == NULL) {
			warning("sendcheckpoint: pid %d: got bad descriptor",
				pid);
			/* XXX This will have clobbered *pd... */
			err = STD_ARGBAD;
		}
		else {
			MON_EVENT("sendcheckpoint: buf_get_pd ok");
			err = STD_OK;
			*pdlen_ret = pdlen;
		}
	}
	if (buf != NULL)
		free((_VOIDSTAR) buf);
	return err;
}

errstat
impl_std_destroy(h, slot)
	header *h;
{	
	if (slot == 0) {
		/* We still have to do rights checking in this case */
		if (!has_rights(&h->h_priv, slot, PSR_KILL))
			return STD_DENIED;

		warning("std_destroy: end of service");
		/* We do the reply here and exit */
		h->h_status = STD_OK;
		(void) putrep(h, NILBUF, 0);
		goaway(0);
		/*NOTREACHED*/
	}
	else {
		MON_EVENT("std_destroy: doesn't apply to pid");
		return STD_COMBAD;
	}
}

/*ARGSUSED*/
errstat
impl_std_info(h, slot, str_ret, max_str_ret, n, len_ret)
	header *h;
	/* out */	char *str_ret;
	/* bound */	int max_str_ret;
	/* in */	int n;
	/* out */	int *len_ret;
{
	char *p;
	char *user;
	
	MON_EVENT("std_info");
	strcpy(str_ret, "session server");
	p = strchr(str_ret, '\0');
	if ((user = getenv("USER")) != NULL) {
		sprintf(p, " for %s", user);
		p = strchr(str_ret, '\0');
	}
	if (PROC_SLOT(slot)) {
		sprintf(p, ", pid %d", proc[slot].pid);
		p = strchr(p, '\0');
	}
	*len_ret = p - str_ret;
	return STD_OK;
}

errstat
impl_std_restrict(h, slot, mask, newcap)
header     *h;
int         slot;
rights_bits mask;
capability *newcap;
{
    port       *check;
    rights_bits rights;

    if (slot == 0) {
	check = &Ses_checkfield;
    } else if (PROC_SLOT(slot)) {
	check = &proc[slot].check;
    } else {
	return STD_CAPBAD;
    }
    if (prv_decode(&h->h_priv, &rights, check) != 0) {
	/* should not happen, it was already checked in find_n_lock */
	warning("prv_decode failed in std_restrict");
        return STD_CAPBAD;
    }

    /* Build new cap: */
    rights &= mask;
    newcap->cap_port = h->h_port;
    if (prv_encode(&newcap->cap_priv, (objnum) slot, rights, check) != 0) {
	warning("prv_encode failed in std_restrict");
        return STD_SYSERR;      /* Shouldn't happen */
    }

    return STD_OK;
}

/*ARGSUSED*/
errstat
impl_tti_interrupt(h, slot, intrchars, max_intrchars)
	header	*h;
	char    *intrchars;
	int	 max_intrchars;
{
	int pgrp;
	int c;
	int sig;
	
	/* XXX should keep the proc group leader around in proctab until
	   proc group is empty! */
	
	if (!PROC_SLOT(slot))
		return STD_CAPBAD;
	/* We still have to do rights checking in this case */
	if (!has_rights(&h->h_priv, slot, PSR_KILL))
		return STD_DENIED;

	pgrp = proc[slot].pid;
	MON_NUMEVENT("tti_interrupt", pgrp);
	c = intrchars[0];
	if (c == ('C' & 0x1f))
		sig = SIGINT;
	else if (c == ('\\' & 0x1f))
		sig = SIGQUIT;
	else {
		warning("tti_interrupt: bad char 0x%x", c);
		return STD_ARGBAD;
	}
	return kill_group(pgrp, sig);
}

/* ARGSUSED */
errstat
impl_tti_signal(h, slot, sig)
	header *h;
	/*in*/	int sig;
{
	int pgrp;
	
	/* XXX should keep the proc group leader around in proctab until
	   proc group is empty! */
	
	if (!PROC_SLOT(slot))
		return STD_CAPBAD;
	/* We still have to do rights checking in this case */
	if (!has_rights(&h->h_priv, slot, PSR_KILL))
		return STD_DENIED;

	pgrp = proc[slot].pid;
	MON_NUMEVENT("tti_signal", pgrp);
	MON_NUMEVENT("tti_signal number", sig);
	return kill_group(pgrp, sig);
}

/*ARGSUSED*/
errstat
impl_ses_getpt(h, slot, pt, max_pt, pnproc)
	header *h;
	struct proctab *pt;
	int max_pt;
	int *pnproc;
{
	int n;
	
	MON_EVENT("ps_getpt");

	if (*pnproc < 0) {
		return STD_ARGBAD;
	}
	if (*pnproc > max_pt) {
		*pnproc = max_pt;
	}

	/* put the session itself first in the table */
	n = 0;
	pt[n].pid = ROOTPID;
	pt[n].ppid = ROOTPID;
	pt[n].pgrp = ROOTPID;
	strncpy(pt[n].state, state_descr(RUNNING), 10);
	pt[n].proc = Session_proccap;
	n++;
	
	for (slot = FIRSTSLOT; slot < MAXNPROC; ++slot) {
		if (proc[slot].state == FREE)
			continue;
		if (n >= *pnproc)
			break; /* Silently forget about the rest */
		pt[n].pid = proc[slot].pid;
		pt[n].ppid = proc[slot].ppid;
		pt[n].pgrp = proc[slot].pgrp;
		strncpy(pt[n].state, state_descr(proc[slot].state), 10);
		pt[n].proc = proc[slot].process;     /* for ps-like programs */
		++n;
	}
	*pnproc = n;
	return STD_OK;
}


/*ARGSUSED*/
errstat
impl_pro_swapproc(h, slot, old, new)
	header *h;
	capability *old, *new;
{
	MON_EVENT("pro_swapproc");
	if (!PROC_SLOT(slot))
		return STD_CAPBAD;
	/* We still have to do rights checking in this case */
	if (!has_rights(&h->h_priv, slot, PSR_EXEC))
		return STD_DENIED;

	if (!cap_cmp(old, &proc[slot].process) || NULLPORT(&new->cap_port))
		return STD_ARGBAD;
	proc[slot].process = *new;
	if (!NULLPORT(&proc[slot].owner.cap_port)) {
		/* Also tell the original owner -- but ignore the answer */
		(void) pro_swapproc(&proc[slot].owner, old, new);
	}
	(void) storeproc(slot, 1);
	return STD_OK;
}

/*ARGSUSED*/
errstat
impl_std_status(h, slot, str_ret, max_str_ret, n, len_ret)
	header *h;
	/* out */	char *str_ret;
	/* bound */	int max_str_ret;
	/* in */	int n;
	/* out */	int *len_ret;
{
	MON_EVENT("std_status");
	if (n <= 1)
		return STD_ARGBAD;
	if (n > max_str_ret) {
		n = max_str_ret;
	}
	strncpy(str_ret, "Cogito ergo sum.\n", (size_t)n);/*XXX no status yet*/
	str_ret[n-1] = '\0';
	*len_ret = strlen(str_ret);
	return STD_OK;
}

/*ARGSUSED*/
errstat
impl_ses_setout(h, obj, cons_tty)
	header *h;
	int obj;
	capability *cons_tty;
{
	errstat err;
	char buf[32];
	int len;
	int fd;
	FILE * fp;

	MON_EVENT("ses_setout");
	/* Set the stdout cap for the session server */
	err = std_info(cons_tty, buf, 32, &len);
	if (obj != 0 || err != STD_OK || (buf[0] != '+' && buf[0] != '-'))
	    return STD_CAPBAD;
	/*
	 * Don't look at the result of the fclose().  Stdout may be
	 * dead or sick.  This remapping of stdout is a miracle of
	 * side-effects.  You're better off not knowing.
	 */
	(void) fclose(stdout);
	if ((fd = opencap(cons_tty, O_WRONLY)) < 0)
	    return STD_CAPBAD;
	if ((fp = fdopen(fd, "w")) == NULL)
	    return STD_SYSERR;

	/* Now remap stderr */
	(void) fclose(stderr);
	if ((fd = opencap(cons_tty, O_WRONLY)) < 0)
	    return STD_CAPBAD;
	if ((fp = fdopen(fd, "w")) == NULL)
	    return STD_SYSERR;

	(void) republish_devconsolecap(cons_tty);
	return STD_OK;
}

static void
dumpproc(slot)
	int slot;
{
	printf("%5d %5d %5d %s\n",
	       proc[slot].pgrp, proc[slot].ppid, proc[slot].pid,
	       state_descr(proc[slot].state));
}

static void
print_ps()
{
	int slot;

	printf(" PGRP  PPID   PID STATE\n");
	for (slot = FIRSTSLOT; slot < MAXNPROC; ++slot) {
		if (proc[slot].state != FREE)
			dumpproc(slot);
	}
	fflush(stdout);
}

/*ARGSUSED*/
static void
statistics(h)
	header *h;
{
	int slot;
	int empty = 1;
	
	for (slot = FIRSTSLOT; slot < MAXNPROC; ++slot) {
		if (proc[slot].state != FREE)
			empty = 0;
	}
	if (empty) {
		MON_EVENT("statistics: PROCESS TABLE EMPTY");
		/* The user might re-login in the next minute,
		 * so stay around for a moment.
		 */
	}
	else if (debugging > 1) {
		print_ps();
	}
}

static errstat
storeproc(slot, replace)
int slot;
int replace; /* Hint only: replacing existing entry */
{
    errstat err;

    err = proc_publish(proc[slot].pid, replace, &proc[slot].process);
    if (err != STD_OK) {
	warning("cannot install process cap for pid %d (%s)",
		proc[slot].pid, err_why(err));
    }
    return err;
}

static errstat
unstoreproc(slot)
int slot;
{
    errstat err;

    err = proc_unpublish(proc[slot].pid);
    if (err != STD_OK) {
	warning("cannot delete process cap for pid %d (%s)",
		proc[slot].pid, err_why(err));
    }
    return err;
}


#if 0

/* Dump bytes in hex, for primitive debugging. */

dumpbytes(buf, nbytes, label)
	char *buf;
	int nbytes;
	char *label;
{
	int i;
	
	printf("%s", label);
	for (i = 0; i < nbytes; ++i) {
		if (i%16 == 0)
			printf("\n%4x ", i);
		printf(" %02x", (unsigned char)buf[i]);
	}
	printf("\n");
	fflush(stdout);
}

#endif

/* Sweeper thread.  At regular intervals, scan the process table for
   processes that have disappeared.  This will cause status to be
   reported when a host crashes. */

#define DEAL_WITH(state) ((state) != FREE && (state) != DEAD)

/*ARGSUSED*/
static void
sweeper(arg, len)
	char *arg;
	int len;
{
	for (;;) {
		errstat err;
		int slot;
		int nprocs;
		long sec;
		int msec, tz, dst;

		sleep(60);

		/* update the time used by the directory server */
		if (tod_gettime(&sec, &msec, &tz, &dst) == STD_OK) {
		    _sp_now = sec;
		} else {
		    MON_EVENT("tod_gettime failed");
		    _sp_now += 60;
		}
		
		mu_lock(&ptmu);
		nprocs = 0;
		for (slot = FIRSTSLOT; slot < MAXNPROC; slot++) {
		    if (proc[slot].state != FREE)
			nprocs++;
		    if (DEAL_WITH(proc[slot].state)) {
			capability process;
			int     n;

			process = proc[slot].process;
			if (!NULLPORT(&process.cap_port)) {
			    /* Do the std_info with ptmu unlocked */
			    mu_unlock(&ptmu);
			    err = std_info(&process, (char *) NULL, 0, &n);
			    mu_lock(&ptmu);
			} else {
			    /* Maybe it still has to be created, so we will
			     * give it a few more chances before we age
			     * out the entry.
			     */
			    err = STD_NOTNOW;
			}

			switch (err) {
			case STD_OK:		/* still there */
			case STD_OVERFLOW:
			    proc[slot].alive = MAX_ALIVE;
			    break;
			case STD_CAPBAD:  	/* already gone */
			    proc[slot].alive = 0;
			    break;
			case RPC_FAILURE:	/* just crashed? */
			case RPC_NOTFOUND:	/* very busy? */
			case STD_NOTNOW:	/* not yet created? */
			default:		/* ? */
			    proc[slot].alive--;
			    break;
			}

			/* If MAX_ALIVE std_info's have failed, assume
			 * the process is dead.  But first check if the
			 * entry is still in use for the same process.
			 */
			if (proc[slot].alive <= 0 &&
			    DEAL_WITH(proc[slot].state) &&
			    cap_cmp(&process, &proc[slot].process))
			{
			    warning("sweeper: process %d assumed dead (%s)",
				    proc[slot].pid, err_why(err));
			    fake_kill(slot);
			}
		    }
		}
		if (nprocs == 0 && !any_activity) {
		    if (!permanent) {
			/* Nothing happened during the last minute
			 * of sleeping, and the process table is empty.
			 * This is a good time to call it a day, if
			 * we were not started with -p (permanent).
			 */
			MON_EVENT("sweeper: no more processes: exit");
			goaway(0);
		    }
		}
		any_activity = 0;
		mu_unlock(&ptmu);
	}
}

start_sweeper()
{
	if (!thread_newthread(sweeper, 8000, (char *)0, 0))
		warning("cannot start process sweeper thread");
}
