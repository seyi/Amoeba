/*	@(#)ttab.c	1.2	94/04/07 14:39:26 */
/*
 * Copyright 1994 Vrije Universiteit and Stichting Mathematisch Centrum,
 * The Netherlands.
 * For full copyright and restrictions on use see the file COPYRIGHT in
 * the top level of the Amoeba distribution.
 */

# include "ail.h"

/*
 *	List to store the types:
 */
static struct typdesc *types = NULL;

/*
 *	Mark all types as not-declared.
 */
void
UnDeclTypes()
{
    struct typdesc *walk;
    for (walk = types; walk != NULL; walk = walk->td_next)
	walk->td_bits &= ~TD_DECLED;
} /* UnDeclTypes */

/*
 *	Add marshaling info to a type, return resulting type.
 *	Such a type can only be a typedef.
 *	If this call stems from a MarshDef; exact is Yes,
 *	meaning that if there is an old definition, it
 *	should be exactly the same.
 *	If not, it is to slightly modify the type for one
 *	particular argument to a remote operation.
 *	Note that this yields a new typedescriptor.
 *	I'm not convinced that the first mentioned semantics
 *	enforce correct buffersize calculations...
 */
struct typdesc *
RecordMarshInfo(type, info, act, max, exact)
    struct typdesc *type;
    struct m_name *info;
    struct etree *act, *max;	/* Actual and maxium sizes	*/
    Bool exact;
{
    struct m_name *old_info;
    if (type == &ErrDesc) return type;
    assert(type->td_kind == TYPEDEF);
    old_info = type->td_marsh;

/* Should verify that this is in the same class as the type?	*/
    if (exact) {

	/*
	 *	I don't know whether I should check size consistency
	 */

	/*
	 *	In case there was a definition yet, the
	 *	marshaling names must be exactly the same
	 */
	if (old_info != NULL &&
	    (old_info->m_clm != info->m_clm ||
	    old_info->m_clu != info->m_clu ||
	    old_info->m_svm != info->m_svm ||
	    old_info->m_svu != info->m_svu)) {
		mypf(ERR_HANDLE, "%r inconsistent marshal redefinition\n");
		return &ErrDesc;
	} else type->td_marsh = info;

	/*
	 *	Everything ok, do it.
	 */
	if (act != NULL) type->td_esize = act;
	if (max != NULL) type->td_msize = max;
    } else {
	mypf(ERR_HANDLE, "%r Too bad; arg marshinfo not implemented\n");
	return &ErrDesc;
    }
    return type;
} /* RecordMarshInfo */

/****************************************\
 *					*
 *	Function for *, [], ().		*
 *					*
\****************************************/

/*
 *	Create an array (or buffer) type.
 *	BUG: I should make a routine to bind the identifiers.
 *	They can be bound to structfields, constants and even
 *	operator arguments.
 */
struct typdesc *
ArrayOf(prim, act, max)
    struct typdesc *prim;	/* The composed-of type */
    struct etree *act;		/* Actual #members	*/
    struct etree *max;		/* Maximum #members	*/
{
    struct typdesc *walk;
    int bits;
    /*
     *	Check against negative sizes
     */
    if (act != NULL && act->et_const && act->et_val < 0) {
	mypf(ERR_HANDLE, "%r Negative array-size\n");
	return &ErrDesc;
    }
    if (max != NULL && max->et_const && max->et_val < 0) {
	mypf(ERR_HANDLE, "%r Negative maximum array-size\n");
	return &ErrDesc;
    }
    /* Errors remain errors	*/
    if (prim == &ErrDesc) return &ErrDesc;
    /* One cannot create arrays composed of functions	*/
    if (prim->td_kind == tk_func) {
	mypf(ERR_HANDLE, "%r Array cannot be contain functions.\n");
	return &ErrDesc;
    }
    /* Try to find the type: it might be used earlier	*/
    for (walk = types; walk != NULL; walk = walk->td_next) {
	if (walk->td_kind == tk_arr &&
	    walk->td_prim == prim &&
	    walk->td_bound == max &&
	    walk->td_act == act) return walk; /* Found */
    }
    /* Not found, insert	*/
    walk = new(struct typdesc);
    walk->td_kind = tk_arr;
    /*
     *	Compute the bits in td_bits:
     */
    bits = TD_CONTXT|TD_CPREF;			/* The ones we need	*/
    bits |= (prim->td_bits & TD_INHERIT);	/* The ones we get	*/
    if (act != NULL && !act->et_const)
	bits |= TD_VARSIZE;
    walk->td_bits = bits;
    walk->td_align = prim->td_align;		/* Use same alignment	*/
    walk->td_parent = ThisClass;
    walk->td_marsh = NULL;
    walk->td_styp = prim->td_styp;
    walk->td_prim = prim;
    walk->td_bound = max;
    walk->td_act  = act;
    /* Compute both sizes	*/
    if (prim->td_esize != NULL) {
	walk->td_msize = (max==NULL) ? NULL : Diadic('*', prim->td_msize, max);
	walk->td_esize = (act==NULL) ? NULL : Diadic('*', prim->td_esize, act);
    } else {	/* Unknown sizes	*/
	walk->td_msize = walk->td_esize = NULL;
    }
    /* Put in the appropiate list: */
    walk->td_next = types;
    types = walk;
    return walk;
} /* ArrayOf */

/*
 *	Create a pointer- or a functiontype.
 *	tk_copy is for the server.
 *	tk_ref is the same as tk_ptr, except
 *	that it is generated by ail itself,
 *	so the size of a ref'd <thing> equals
 *	the size of <thing>.
 */
struct typdesc *
DefPRF(prim, kind)
    struct typdesc *prim;	/* The composed-of type	*/
    int kind;			/* Funcion or pointer	*/
{
    struct typdesc *walk;
    /* Errors remain errors. */
assert(kind == tk_copy || kind == tk_func || kind == tk_ptr || kind == tk_ref);
    if (prim == &ErrDesc) return &ErrDesc;
    /* One cannot create functions composed of functions. */
    if (prim->td_kind == tk_func && kind == tk_func) {
	mypf(ERR_HANDLE, "%r Illegal type composed of function.\n");
	return &ErrDesc;
    }
    /* Try to find the type: it might be used earlier. */
    for (walk = types; walk != NULL; walk = walk->td_next) {
	if (walk->td_kind == kind && walk->td_prim == prim)
	    return walk;	/* Found */
    }
    /* Not found, insert. */
    walk = new(struct typdesc);
    walk->td_kind = kind;
    walk->td_parent = ThisClass;
    if (kind == tk_ref || kind == tk_copy) {	/* Ail-generated types	*/
	walk->td_marsh = prim->td_marsh;
	walk->td_align = prim->td_align;	/* These are copies	*/
	walk->td_esize = prim->td_esize;
	walk->td_msize = prim->td_msize;
    } else {			/* Function or pointer: uninterpreted	*/
	walk->td_align = 0;
	walk->td_marsh = NULL;
	walk->td_msize = walk->td_esize = NULL;
    }
    /* Copies are quite strange...	*/
    if (kind == tk_copy) {
	assert(prim->td_kind == tk_ref);
	walk->td_bits = prim->td_prim->td_bits;
	/* Get rid of the intermediate tk_ref	*/
	walk->td_prim = prim->td_prim;
    } else {
	walk->td_bits = (kind == tk_ref || kind == tk_ptr) ?
	    TD_CONTXT : TD_CONTXT|TD_CPREF;
	walk->td_bits |= prim->td_bits & TD_INHERIT;
	walk->td_prim = prim;
    }
    walk->td_styp = prim->td_styp;
    /* Put in the appropiate list: */
    walk->td_next = types;
    types = walk;
    return walk;
} /* DefPRF */

/*
 *	Check marshaling info
 */
static void
CheckMinfo(p)
    struct typdesc *p;
{
    struct m_name *mn;
    mn = p->td_marsh;
    if (mn != NULL) {
	if (p->td_bits & TD_INHERIT) {
	    /* The prototypes for the client and server differ */
	    if (mn->m_clm == mn->m_svm && mn->m_clm != NULL) {
		mypf(ERR_HANDLE,
		"%r type %s cannot use same marshaler at client and server\n",
		p->td_tname);
	    }
	    if (mn->m_clu == mn->m_svu && mn->m_clu != NULL) {
		mypf(ERR_HANDLE,
		"%r type %s cannot use same unmarshaler at client and server\n",
		p->td_tname);
	    }
	}
    }
} /* CheckMinfo */

/*
 *	Make a typedef.
 *	It is important that repeated, consistent typedefs
 *	are accepted, since the initialisation routine that
 *	knows about capability, port, private and header
 *	also use these routines.
 *	This gives you a runtime compatibility check between
 *	ail and your version of amoeba.h
 */
struct typdesc *
NewTD(name, tp)
    char *name;
    struct typdesc *tp;
{
    struct typdesc *ret;
    struct name *nm;
    struct class *clp;
    if (options & OPT_DEBUG) mypf(OUT_HANDLE, "NewTD(%s)\n", name);
    tp = SameType(tp);
    if (WhereIsName(name, &clp, &nm)) {
	/* Previously declared; consistent?	*/
	if (nm->nm_kind == STRUCT || nm->nm_kind == UNION ||
	    nm->nm_kind == UNION) {
		/*
		 * Exception to the rule that an identifier had only
		 * one meaning; typedef struct foo { <whatever> } foo;
		 */
		if (nm->nm_type != tp) {
		    mypf(ERR_HANDLE, "%r typedef %s is different from %s %s\n",
			name, TokenToString(nm->nm_kind), name);
		    return &ErrDesc;
		}
	} else if (nm->nm_kind == TYPEDEF && nm->nm_type->td_prim == tp) {
	    assert(nm->nm_type->td_kind == TYPEDEF);
	    return nm->nm_type;
	} else {
	    if (nm->nm_type != &ErrDesc)	/* Previous error	*/
		mypf(ERR_HANDLE, "%r inconsistent typedef %s\n", name);
	    return &ErrDesc;
	}
    }
    ret = new(struct typdesc);
    ret->td_kind = tk_tdef;
    ret->td_align = tp->td_align;	/* Doesn't change for typedefs	*/
    ret->td_parent = ThisClass;
    ret->td_bits = tp->td_bits & ~TD_CONTXT;
    ret->td_esize = tp->td_esize;	/* Same sizes as derived-from	*/
    ret->td_msize = tp->td_msize;
#if 0	/* Why did I do this!?	*/
    if (ret->td_esize == NULL) ret->td_esize = Cleaf((long) 0);
#endif
    ret->td_marsh = NULL;
    ret->td_tname = name;
    ret->td_styp = ret;	/* Typedefs can be used as a simpletype. */
    ret->td_prim = tp;
    ret->td_next = types;
    types = ret;
    /* Store the name in the current scope:	*/
    nm = NewName(name, TYPEDEF);
    if (nm != NULL) nm->nm_type = ret;
    CheckMinfo(ret);
    assert(ret->td_prim != NULL);
    return ret;
} /* NewTD */

struct typdesc *
IsTD(id)
    char *id;
{
    struct name *nm;
    assert(ThisClass != NULL);
    dbg3("IsTD(%s %p)\n", id, id);
    if ((nm = WhereIsTD(id)) != NULL) {
	return nm->nm_type; /* Found */
    }
    return NULL;	/* Something incorrect	*/
} /* IsTD */

/*
 *	Return the same type as was passed, i.e. discard
 *	irrelevant typedef's.
 */
struct typdesc *
SameType(t)
    struct typdesc *t;
{
    while (t->td_kind == tk_tdef && t->td_marsh == NULL) t = t->td_prim;
    return t;
} /* SameType */

/************************************************\
 *						*
 *	Functions for su's (struct, union).	*
 *						*
\************************************************/

/* Compare two memberlists. */
static Bool
MlEqu(m1, m2)
    struct itlist *m1, *m2;
{
    while (m1 != NULL && m2 != NULL) {
	if (m1->il_name != m2->il_name || m1->il_type != m2->il_type) {
	    return No;
	}
	m1 = m1->il_next;
	m2 = m2->il_next;
    }
    assert(m1 == NULL || m2 == NULL);
    return m1 == m2;
} /* MlEqu */

/*
 *	Find a tagged struct/union/enum.
 *	Since the tags of structures, unions and enums are in a separate
 *	namespace on C-implementations, we put the name in GlobClass.
 */
struct typdesc *
FindSUE(kind, name)
    int kind;
    char *name;
{
    struct typdesc *walk;
    struct name *nm;
    assert(name != NULL);
/*  assert(kind == tk_struct);	Enums and unions are not really supported */
    nm = FindName(name, GlobClass.cl_scope);
    if (nm != NULL) {
	if (kind != nm->nm_kind) {
	    mypf(ERR_HANDLE, "%r %s is already defined\n", name);
	    return &ErrDesc;
	}
	return nm->nm_type;
    }

    /* Not found; create. This is contrived because C's scoping rules are */
    walk = new(struct typdesc);
    { struct class *OldClass;	/* To fool NewName()	*/
	OldClass = ThisClass; ThisClass = &GlobClass;
	nm = NewName(name, kind);
	ThisClass = OldClass;
    }
    assert(nm != NULL);		/* We just checked its plausibility	*/
    nm->nm_type = walk;
    if (ThisClass != &GlobClass) { /* Otherwise we just did exactly this */
	nm = NewName(name, kind);
	if (nm == NULL) return &ErrDesc;
	nm->nm_type = walk;
    }
    walk->td_kind = kind;
    walk->td_bits = 0;
    walk->td_align = 0;		/* Not known yet; we don't know the members */
    walk->td_esize = walk->td_msize = NULL;
    walk->td_marsh = NULL;
    walk->td_next = types; types = walk;
    walk->td_styp = walk;
    walk->td_parent = ThisClass;
    walk->td_meml = NULL;
    walk->td_name = name;
    walk->td_defd = No;
    return walk;
} /* FindSUE */

/*
 *	Compute size, alignment requirements and properties
 *	like contains-int.
 *	Structs might need a hole at the end in order to
 *	be able to put them in arrays.
 *
 *	Scheduled to be used for message-size calculation.
 *	Types ail doesn't support itself have alignment 0,
 *	chars (which in fact have no alignment _requirement_)
 *	have 1, shorts 2 and so on. (Sorry; can't think of
 *	a better place to put this comment).
 *
 *	"offset" doesn't always contain the exact offset
 *	within the message header; it can't: some sizes are
 *	computed runtime, so I'm pessimistic. When I can't
 *	compute the real offset, I use the last alignment
 *	requirement as offset, which works since structs
 *	are padded at the end. If I don't even know the
 *	alignment after a certain type, I set it to 1,
 *	which is a worst-case assumption with respect to
 *	the sizes of the required holes.
 *
 *	Structure of this routine:
 *
 *		inits;
 *		for (each member in the list) {
 *			remember type bits;
 *			Add both sizes (max & act) to this type's size;
 *			advance to next member;			(!!)
 *			compute size of required hole;
 *			Add size of hole to both sizes and offset;
 *		}
 *		Update type-bits;
 */

static void
StructSniffle(type)
    struct typdesc *type;
{
    int this_align;		/* Alignment of this member		*/
    int bits = 0;		/* The td_bits				*/
    int offset = 0;		/* Offset of this member		*/
    Bool e_wrong = No, m_wrong = No;	/* Offset ok for e_size/m_size?	*/
    struct itlist *mlist;

    type->td_align = 1;		/* Assume no initial restriction	*/
    type->td_msize = type->td_esize = Cleaf((long) 0);	/* Empty	*/
    /*	Loop over the members	*/
    for (mlist = type->td_meml; mlist != NULL; ) {
	register struct typdesc *mtype;
	int hole;		/* Size of padding hole			*/

	mtype = mlist->il_type;	/* Type of this member			*/
	mlist->il_offs = e_wrong ? -1 : offset;
	/* If we e.g. contain an int, we'd like to know			*/
	bits |= mtype->td_bits;	/* Too many bits; masked of later on	*/

	/*
	 *	Remember biggest alignment requirement
	 */
	if (mtype->td_align > type->td_align)
	    type->td_align = mtype->td_align;

	/*
	 *	Add size of this element, update offset
	 *	The offset depends on the actual size only
	 */
	if (mtype->td_esize == NULL) {	/* Size of this member unknown	*/
#ifdef NOISY
	    mypf(ERR_HANDLE, "%w cannot compute size of %s\n", mlist->il_name);
#endif
	    /*
	     *	Hmm, does this imply that ail won't
	     *	interface with ungeneratable marshalers?
	     */	
	    e_wrong = m_wrong = Yes;	/* But continue to calc bits!	*/
	} else {
	    assert(offset % mtype->td_align == 0); /* Properly aligned	*/
	    /* Add member size	*/
	    type->td_esize = Diadic('+', type->td_esize, mtype->td_esize);

	    if (mtype->td_esize->et_const) {	/* Size known		*/
		assert(mtype->td_esize->et_val >= 0);
		offset += mtype->td_esize->et_val;
	    } else {
		e_wrong = Yes;
		offset = mtype->td_align;
		if (offset == 0) offset = 1;	/* Worst case		*/
	    }
	}
	/* Max size:	*/
	if (mtype->td_msize != NULL) {
	    type->td_msize = Diadic('+', type->td_msize, mtype->td_msize);
	}

	/*
	 *	Advance; compute size of hole (pessimistic)
	 */
	mlist = mlist->il_next;			/*	!!		*/
	if (mlist == NULL) {			/* Was last member; pad	*/
	    this_align = type->td_align;	/* Severest alignment	*/
	} else {
	    this_align = mlist->il_type->td_align;
	    if (this_align < 1) this_align = 1;	/* Worst case		*/
	}
	hole = this_align - (offset % this_align);
	if (hole == this_align) hole = 0;
	assert(hole < MAX_ALIGN);		/* No bigger primaries	*/

	/*
	 *	Add sizes of the hole
	 */
	type->td_esize = Diadic('+', type->td_esize, Cleaf((long) hole));
	type->td_msize = Diadic('+', type->td_msize, Cleaf((long) hole));
	offset += hole;
    }
    if (m_wrong) {
	type->td_align = 0;	/* Don't know alignment restrictions	*/
	type->td_esize = type->td_msize = NULL; /* Forget computed size */
    }
    type->td_bits |= (bits & TD_INHERIT);	/* Or in the bits we need */
/* ShowType(type); */
} /* StructSniffle */

static void
UnionSniffle(t)
    struct typdesc *t;
{
    struct itlist *mem;
    Bool pech = No;
    t->td_align = 1;		/* Assume no initial restriction	*/
    t->td_msize = t->td_esize = Cleaf((long) 0);	/* Empty	*/
    /* Loop over the members:	*/
    for (mem = t->td_meml; mem != NULL; mem = mem->il_next) {
	/* All fields start at offset 0	*/
	mem->il_offs = 0;
	/* Containing anything remarkable?	*/
	t->td_bits |= mem->il_type->td_bits & TD_INHERIT;
	/* Stricter alignment?	*/
	if (mem->il_type->td_align > t->td_align)
	    t->td_align = mem->il_type->td_align;
	/* Update sizes:	*/
	if (!pech && mem->il_type->td_esize != NULL
	&& mem->il_type->td_msize != NULL) {
	    t->td_esize = Diadic('m', t->td_esize, mem->il_type->td_esize);
	    t->td_msize = Diadic('m', t->td_msize, mem->il_type->td_msize);
	} else pech = Yes;
    }
} /* UnionSniffle */

/*
 *	Define a struct or union
 */
struct typdesc *
DefSU(kind, name, mlist)
    int kind;
    char *name;
    struct itlist *mlist;
{
    struct typdesc *ret;
    assert(kind == tk_struct || kind == tk_union);
    if (name == NULL) {
	static struct typdesc *untagged = NULL;
	/* Maybe an equivalent SU has been entered yet */
	for (ret = untagged; ret != NULL; ret = ret->td_next) {
	    if (ret->td_kind == kind && MlEqu(mlist, ret->td_meml)) {
		dbg1("Unnamed-equal sue\n");
		return ret;
	    }
	}
	/* No, gotta create one. */
	ret = new(struct typdesc);
	ret->td_kind = kind;
	ret->td_parent = ThisClass;
	ret->td_bits = TD_CONTXT;	/* Needs no declaration	*/
	ret->td_marsh = NULL;
	/* Sues, wether they're tagged or not, are SimpleTypes	*/
	ret->td_styp = ret;
	ret->td_name = name;
	/* Put in list	*/
	ret->td_next = untagged;
	untagged = ret;
    } else if ((ret = FindSUE(kind, name))->td_defd) {
	if (MlEqu(ret->td_meml, mlist)) {
	    /* Legal redefinition	*/
	    /* Don't need to set td_align or td_bits again here	*/
	    dbg2("Equal sue %s\n", name);
	    return ret;
	}
	/* Same name, different memberlist. */
	mypf(ERR_HANDLE, "%r struct or union \"%s\" redeclared\n", name);
	return &ErrDesc;
    } /* Else: only the name existed, and we're here to define it	*/
    /* Attach member list; mark as declared	*/
    ret->td_meml = mlist;
    ret->td_defd = Yes;
    if (kind == tk_struct) StructSniffle(ret);
    else UnionSniffle(ret);
    return ret;
} /* DefSU */

/********************************\
 *				*
 *	For enumerated types	*
 *				*
\********************************/

/*
 *	Test equality for a list of enum-constants
 *	I don't think this can possibly work; since
 *	list n2 is reversed, but i1 is not.
 */
static Bool
EconEqu(i1, n2)
    struct itlist *i1;
    struct name *n2;
{
    while (i1 != NULL) {
	struct name *n1;
	if (n2 == NULL) return No;
	n1 = i1->il_econ;
	if (n1->nm_name != n2->nm_name	/* Different identifier	*/
	|| n1->nm_ival != n2->nm_ival)	/* Different value	*/
	    return No;
	i1 = i1->il_next;
	n2 = n2->nm_next;
    }
    return n2 == NULL;
} /* EconEqu */

/*
 *	Define an enum.
 *	Enums are special in that they declare constants
 *	in the scope in which THEY are declared by magic.
 *	The nodes in nlist are reversed.
 */
struct typdesc *
DefEnum(name, nlist)
    char *name;
    struct name *nlist;
{
    struct typdesc *ret;
    if (name == NULL) {
	/* Keep a secret list of untagged enum-types: */
	static struct typdesc *enums = NULL;

mypf(ERR_HANDLE, "%w Please tag your enums or wait for Ail to be fixed\n");
assert(No);	/* EconEqu is sick	*/
	for (ret = enums; ret != NULL; ret = ret->td_next) {
	    if (EconEqu(ret->td_meml, nlist)) return ret;
	}
	/* None defined yet	*/
	ret = new(struct typdesc);
	ret->td_kind = tk_enum;
	ret->td_bits = TD_CONTXT;
	ret->td_parent = ThisClass;
	ret->td_marsh = NULL;
	ret->td_styp = ret;
	ret->td_name = NULL;
	/* Put in list */
	ret->td_next = enums;
	enums = ret;
	return ret;
    }
    /*
     *	Initialise descriptor
     */
    ret = FindSUE(tk_enum, name);
    if (ret->td_defd) {
/* BUG; already defined: should check they are equal	*/
	return ret;
    }
    ret->td_bits |= TD_CONTINT;
    ret->td_align = 4;	/* Align like longs	*/
    ret->td_esize = ret->td_msize = Cleaf((long) 4);
    ret->td_marsh = NULL;
    ret->td_styp = ret;
    ret->td_defd = Yes;
    /*
     *	Build an itlist pointing to the constants
     *	Put the constants in the symbol table of ThisClass
     */
    ret->td_meml = NULL;
    while (nlist != NULL) {
	struct  itlist *itmp;
	struct name *ntmp;
	/* Put the constant in the symbol table	*/
	ntmp = nlist;
	ntmp->nm_type = ret;	/* Which enumerated type	*/
	nlist = nlist->nm_next;
	InsName(ntmp);
	/* Link in ip	*/
	itmp = new(struct itlist);
	itmp->il_next = ret->td_meml; ret->td_meml = itmp;
	itmp->il_type = ret;
	itmp->il_name = ntmp->nm_name;
	itmp->il_econ = ntmp;
	itmp->il_bits = 0;	/* Unused	*/
    }
    return ret;
} /* DefEnum */

/************************************************\
 *						*
 *	Functions to modify standard-types.	*
 *						*
\************************************************/

/*
 *	Make a size/sign variant of a standard type.
 *	These are always part of the universe.
 */
/* static */ struct typdesc *
StdVariant(tk, size, sign)
    int tk;	/* The type-kind. */
    int size, sign;
{
    struct typdesc *tp;
    static struct typdesc *machine_types = NULL;
    /* Check if we got a typdesc for this one yet: */
    for (tp = machine_types; tp != NULL; tp = tp->td_next) {
	if (tp->td_kind == tk && tp->td_size == size && tp->td_sign == sign)
		return tp;	/* Found */
    }
    /* Not found, make a new typdesc */
    tp = new(struct typdesc);
    tp->td_kind = tk;
    tp->td_parent = &GlobClass;
    tp->td_bits = TD_DECLED;
    tp->td_marsh = NULL;
    dbg5("StdVariant %d(Size %d, sign %d) at %p\n", tk, size, sign, tp);
    switch (tk) {
    case tk_char:
	tp->td_msize = tp->td_esize = Cleaf((long) 1);
	tp->td_align = 1;
	break;
    case tk_int:
	tp->td_bits |= TD_CONTINT;
	switch (size) {
	case -1:	/* "short"		*/
	    tp->td_msize = tp->td_esize = Cleaf((long) 2);
	    tp->td_align = 2;
	    break;
	case 0:		/* long on the wire	*/
	    tp->td_msize = tp->td_esize = Cleaf((long) 4);
	    tp->td_align = 4;
	    break;
	case 1:		/* "long"		*/
	    tp->td_msize = tp->td_esize = Cleaf((long) 4);
	    tp->td_align = 4;
	    break;
	default:	/* long long or something	*/
	    tp->td_msize = tp->td_esize = NULL;
	    tp->td_align = 0;
	}
	break;
    case tk_float:
	tp->td_bits |= TD_CONTFLT;	/* A float contains a float	*/
	tp->td_msize = tp->td_esize = Cleaf((long) 4);
	tp->td_align = 0;
	break;
    case tk_double:
	tp->td_bits |= TD_CONTFLT;	/* A double contains a float	*/
	tp->td_msize = tp->td_esize = Cleaf((long) 8);
	tp->td_align = 0;
	break;
    default:
	assert(tk == tk_void);
	tp->td_msize = tp->td_esize = NULL;	/* Unknown size		*/
    }
    tp->td_styp = tp;
    tp->td_size = size;
    tp->td_sign = sign;
    /* Put in list: */
    tp->td_next = machine_types;
    machine_types = tp;
    return tp;
} /* StdVariant */

/*
 *	Construct a typdesc built of modifiers only.
 */
struct typdesc *
ModifTyp(kind, lc, sc, sign)
    int kind;
    unsigned lc, sc;
    int sign; /* -1: signed, 0: unspecified, 1: unsigned */
{
    int size; /* -2=very short, -1=short, 0=unspecified, 1=long, etc	*/
    if (kind == tk_err) return &ErrDesc;
    if (kind == tk_dunno) kind = tk_int;
    if (lc && sc) {
	mypf(ERR_HANDLE, "%r Long and short don't mix\n");
	return &ErrDesc;
    }
    size = lc - sc;
    switch (kind) {
    case tk_char:
	if (size) {
	    mypf(ERR_HANDLE, "%r Chars cannot be resized\n");
	    return &ErrDesc;
	}
	/* Are chars signed or unsigned by default? */
	return StdVariant(tk_char, size, sign);
    case tk_float:
    case tk_double:
	if (sign) {
	    mypf(ERR_HANDLE, "%r (Un)signed floats don't exist\n");
	    return &ErrDesc;
	}
	return StdVariant(kind, size, 0);
    case tk_int:
	/* There are no restrictions on ints. */
	if (sign == 0) sign = -1;	/* Sign defaults to signed */
	return StdVariant(tk_int, size, sign);
    case tk_void:
	if (sign || size) {
	    mypf(ERR_HANDLE, "%r One cannot modify voids\n");
	    return &ErrDesc;
	}
	return StdVariant(tk_void, 0, 0);
    default:
	mypf(ERR_HANDLE, "%d: ", kind);
	fatal("stdtype not yet implemented");
	/*NOTREACHED*/
    }
    /*NOTREACHED*/
} /* ModifTyp */

/****************************************\
 *					*
 *	Miscellaneous functions:	*
 *					*
\****************************************/

void
SymInit()
{
    /* Initialize machinetypes	*/
    ErrDesc.td_kind = tk_err;
    ErrDesc.td_bits = TD_DECLED;
    ErrDesc.td_styp = NULL;
    ErrDesc.td_msize = ErrDesc.td_esize = NULL;
    ErrDesc.td_sign = 0;
    ErrDesc.td_next = (struct typdesc *) NULL;

#ifdef STRING
    StrDesc.td_kind = tk_string;
    StrDesc.td_bits = TD_DECLED;
    StrDesc.td_styp = NULL;
    StrDesc.td_msize = NULL;
    StrDesc.td_esize = 0x1L;	/* Should be: strlen(arg)	*/
    StrDesc.td_next = (struct typdesc *) NULL;
#endif

    /* Init the universe	*/
    GlobClass.cl_name = "The Universe";
    GlobClass.cl_definh = NULL;
    GlobClass.cl_effinh = NULL;
    GlobClass.cl_last = GlobClass.cl_lo = GlobClass.cl_hi = 0;
    GlobClass.cl_scope = NULL;
} /* SymInit */
