/*	@(#)declare.c	1.3	94/04/07 14:48:21 */
/*
 * Copyright 1994 Vrije Universiteit, The Netherlands.
 * For full copyright and restrictions on use see the file COPYRIGHT in the
 * top level of the Amoeba distribution.
 */

#include <assert.h>
#include <stdio.h>
#include "dbug.h"
#include "global.h"
#include "expr.h"
#include "eval.h"
#include "execute.h"
#include "declare.h"
#include "lexan.h"
#include "slist.h"
#include "objects.h"
#include "conversion.h"
#include "Lpars.h"
#include "type.h"

/* Problem with declarations: the object(s) it declares may not be available
 * yet (they might be generated by a program).  Because declarations
 * take precedence above derivations (that's why we introduced them) we
 * must at least wait until the object(s) are known, so that the given 
 * attributes may be set to BUSY. We shouldn't have to wait for the actual
 * values of the attributes, but this is not yet implemented.
 */

PRIVATE int ClassDeclare, ClassInclude, ClassDefault;

PUBLIC void
EnterDeclaration(decl)
struct expr *decl;
{
    struct job *job;

    DBUG_ENTER("EnterDeclaration");
    job = CreateJob(ClassDeclare, (generic)decl);
    PutInReadyQ(job);
    StartExecution(/*until*/job/*is finished*/);
    DBUG_VOID_RETURN;
}

PUBLIC void
EnterInclusion(incl)
struct expr *incl;
{
    struct job *job;

    DBUG_ENTER("EnterInclusion");
    job = CreateJob(ClassInclude, (generic)incl);
    PutInReadyQ(job);
    StartExecution(/*until*/job/*is finished*/);
    DBUG_VOID_RETURN;
}

PUBLIC void
EnterDefault(def)
struct expr *def;
{
    struct job *job;

    DBUG_ENTER("EnterDefault");
    job = CreateJob(ClassDefault, (generic)def);
    PutInReadyQ(job);
    StartExecution(/*until*/job/*is finished*/);
    DBUG_VOID_RETURN;
}

PRIVATE void
DoDeclare(decl)
struct expr **decl;
{
    *decl = Eval(*decl);
    DBUG_PRINT("job", ("declaration done"));
}

PRIVATE struct object *CurFile;

PRIVATE void
DoInclude(incl)
struct expr **incl;
{
    CurFile = CurrentFile(); /* for the benefit of PrInclusion, below */

    *incl = Eval(*incl);
    DBUG_WRITE(("include: ")); DBUG_Expr(*incl); DBUG_NL();
    *incl = GetExprOfType(*incl, T_LIST_OF | T_OBJECT);
    LexanInsert((*incl)->e_list);
    DBUG_PRINT("incl", ("inclusion done"));
}

PRIVATE struct slist *Defaults = NULL;

PUBLIC struct slist *
GetDefaults()
{
    return(Defaults);
}

PRIVATE void
DoDefault(def)
struct expr **def;
{
    *def = Eval(*def);
    *def = GetExprOfType(*def, T_LIST_OF | T_OBJECT);
    ITERATE((*def)->e_list, expr, obj, {
	Append(&Defaults, obj);
    });
    DBUG_PRINT("decl", ("defaults done"));
}

/*ARGSUSED*/
PRIVATE char *
PrDeclaration(decl)
struct expr *decl;
{
    return("declaration");
}

/*ARGSUSED*/
PRIVATE char *
PrInclusion(incl)
struct expr *incl;
{
    /* This function is only called when a file to be included cannot be
     * found.  As that fact is already reported, we return the file
     * from which the inclusion takes place rather than the included file
     * itself.
     */
    if (CurFile != NULL) {
	(void)sprintf(ContextString, "current file is `%s'",
		     SystemName(CurFile));
	return(ContextString);
    } else {
	return("inclusion");
    }
}

/*ARGSUSED*/
PRIVATE char *
PrDefault(def)
struct expr *def;
{
    return("default");
}

PRIVATE void
RmExpr(e)
struct expr *e;
{
    put_expr(e);
}

PUBLIC void
InitDeclare()
{
    ClassDeclare = NewJobClass("declaration", (void_func) DoDeclare,
			     (void_func) RmExpr, (string_func) PrDeclaration);
}

PUBLIC void
InitInclude()
{
    ClassInclude = NewJobClass("inclusion", (void_func) DoInclude,
			      (void_func) RmExpr, (string_func) PrInclusion);
}

PUBLIC void
InitDefault()
{
    ClassDefault = NewJobClass("default", (void_func) DoDefault,
			      (void_func) RmExpr, (string_func) PrDefault);
}


