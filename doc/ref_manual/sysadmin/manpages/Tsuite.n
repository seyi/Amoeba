.\"	@(#)Tsuite.n	1.6	96/02/22 16:37:03
.\"
.\" Copyright 1996 Vrije Universiteit, The Netherlands.
.\" For full copyright and restrictions on use see the file COPYRIGHT in the
.\" top level of the Amoeba distribution.
.\"
.aU
	Software: various authors
	Document: Berend Jan Beugel, July 25, 1991.
	Modified: Kees Verstoep, Sept 14, 1993: describe ALL tests
		  Gregory J. Sharp, Feb 1996
.aE
.kW "test suite"
.kW "test program"
.kW "performance measurement"
.mT "Tsuite" T
a suite of test programs for \*(Am
.SH
Description
.LP
The test suite for \*(Am consists of a set of test programs and shell scripts
that verify stubs, functions and utilities.
Also included is a set of performance measuring programs.
The name of a test program
or script usually starts with a capital
.I `T'.
.LP
Test programs and scripts generally test valid and invalid test cases.
Valid cases use valid parameters, operations or input data.
Invalid cases verify that stubs, functions and utilities return
correct error codes for invalid parameters, operations or input data.
.LP
Most programs in the test suite have options and arguments to change their
default behavior.
.LP
Some test programs verify an entire server interface.
It is suggested that
these tests are run on separate servers to avoid interference with the
normal daily operation of \*(Am.
.mH
Overview of the test programs available
.sp 1
.IP \fITsoap\fP 12
.kW \fITsoap\fP
A comprehensive test program for the directory service.
See
.I Tsoap (T).
.IP \fITbullet\fP
.kW \fITbullet\fP
.IP \fITbullet1\fP
.kW \fITbullet1\fP
.IP \fITbulletc\fP
.kW \fITbulletc\fP
A set of test programs for the Bullet file server.
See
.I Tbullet (T).
.IP \fITmulti_bullet\fP
.kW \fITmulti_bullet\fP
.br
This is an interactive program checking the integrity of the \*(Bs
when doing a specified set of file operations.
All file operations are performed in parallel by a specified number of threads,
unless sequential mode of operation is requested.
.br
Usage:
.sC
Tmulti_bullet bulletsvr [alternate-bulletsvr]
.eC
The alternate bullet server is optional.
It is only needed when testing the
.I std_copy
operation.
.IP \fITgetdef\fP
.kW \fITgetdef\fP
A simple program checking the
.I pro_getdef
request.
.br
Usage:
.sC
Tgetdef procsvr
.eC
The argument
.I procsvr
is the process server of a certain host, e.g.,
.I /super/hosts/dodo/proc .
.IP \fITgetload\fP
.kW \fITgetload\fP
A simple program checking the
.I pro_getload
request.
.br
Usage:
.sC
Tgetload procsvr
.eC
.IP \fITgetowner\fP
.kW \fITgetowner\fP
A simple program checking the
.I pro_getowner
request.
.br
Usage:
.sC
Tgetowner process-cap
.eC
For example,
the following sequence of commands can be used
to inspect the owner of the session server.
.sC
$ aps -v
PID PPID PGRP STATE   T OWNER          COMMAND
  1    1    1 RUNNING R ax server      session -a
  2    1    2 WAITING R session server -ksh
 53    2    2 RUNNING R session server aps -v
$ Tgetowner /dev/proc/1
Owner of '/dev/proc/1' is E:D:F:5:F:9/0(0)/0:0:0:0:0:0
$ a2c 'E:D:F:5:F:9/0(0)/0:0:0:0:0:0' ownercap
$ std_info ownercap
ax server for versto
.eC
.IP \fITsetowner\fP
.kW \fITsetowner\fP
A simple program checking the
.I pro_setowner
request.
.br
Usage:
.sC
Tsetowner process-cap new-owner-cap
.eC
For example,
the following sequence of commands changes the owner
of the session server to itself.
.sC
$ Tsetowner /dev/proc/1 /dev/session
Owner of '/dev/proc/1' set to '/dev/session'.
$ aps -v                                  
PID PPID PGRP STATE   T OWNER          COMMAND
  1    1    1 RUNNING R session server session -a
  2    1    2 WAITING R session server -ksh
 58    2    2 RUNNING R session server aps -v
.eC
.IP \fITdeepen\fP
.kW \fITdeepen\fP
This program calls a few recursive functions.
It is mainly used to check the correct handling of the
window overflow and underflow interrupts generated by the
.I sparc
processor.
.IP \fITstackovf1\fP
.kW \fITstackovf1\fP
.IP \fITstackovf2\fP
.kW \fITstackovf2\fP
These programs check that stack overflow will result in
a program crash.
.IP \fITrnd1\fP
.kW \fITrnd1\fP
.IP \fITrnd2\fP
.kW \fITrnd2\fP
These programs check the correct working of the random number server.
.br
Usage:
.sC
Trnd1 [randomsvr]
Trnd2 [randomsvr]
.eC
If the random numver server is not specified,
the default one (typically
.I /profile/cap/randomsvr/default )
is used.
.IP \fITprio1\fP
.kW \fITprio1\fP
.IP \fITprio2\fP
.kW \fITprio2\fP
.IP \fITprio3\fP
.kW \fITprio3\fP
These programs check the correct working of preemptive priority scheduling.
.br
Usage:
.sC
Tprio1 nthreads
Tprio2 [nthreads]
Tprio3
.eC
.IP \fITfloatp\fP
.kW \fITfloatp\fP
.IP \fITctest\fP
.kW \fITctest\fP
These programs perform a number of computations,
including floating point operations.
The programs can be used to check that the floating point status is
saved correctly by running multiple instances on the same host in parallel.
.IP \fITpipe\fP
.kW \fITpipe\fP
This program checks the integrity of the
.I pipe
implementation of \*(Am.
See
.I Tpipe (T).
.IP \fITsignal\fP
.kW \fITsignal\fP
This program checks the correct working of the POSIX
signal emulation under \*(Am.
See
.I Tsignal (T).
.IP \fITam_signals\fP
.kW \fITam_signals\fP
This program checks the correct working of (light-weight) \*(Am signals.
See
.I Tam_signals (T).
.IP \fITmsg_client\fP
.kW \fITmsg_client\fP
.IP \fITmsg_server\fP
.kW \fITmsg_server\fP
These two programs test the fault-tolerant message-based RPC library (see
.I msg_rpc (L)
and
.I msg (L)).
Before starting the tests,
make sure that the necessary directories exist as specified by
.cW RRPC_GRP_DIR
and
.cW RRPC_CTX_DIR
in
.I ampolicy.h .
Then start one or more
.I Tmsg_server
programs in the background and execute
.I Tmsg_client .
The client will send the integers \*<1\*> to \*<500\*>
to the replicated service,
and wait for a reply.
The protocol implemented should guarantee correct behavior
even when all but one of the
.I Tmsg_server
programs crashes.
.br
Usage:
.sC
Tmsg_client [-v] [-s]
Tmsg_server [-v] [-s]
.eC
The
.B \-v
option switches the program to verbose mode.
The
.B \-s
option increases the waiting time for each RPC
with one second (default is immediate response).
.IP \fITmsg_grp1\fP
.kW \fITmsg_grp1\fP
.IP \fITmsg_grp2\fP
.kW \fITmsg_grp2\fP
These two programs test the message-based group management library (see
.I msg_grp (L)
and
.I msg (L)).
Before starting the tests,
make sure the necessary directories exist as specified by
.cW RRPC_GRP_DIR
and
.cW RRPC_CTX_DIR
in
.I ampolicy.h .
Then start multiple instances of either program in the background.
The program
.I Tmsg_grp1
will send the integers \*<0\*> to \*<500\*> to all replicas
and exit when it receives its last message back.
Program
.I Tmsg_grp2
sends over additional information to check the correctness
of the various marshaling routines.
.IP \fITstack\fP
.kW \fITstack\fP
This is a simple test of the threads implementation to show that each
thread is running on its own stack.
.IP \fITfromb.sh\fP
.kW \fITfromb.sh\fP
This shell script creates ten files with various contents on the Bullet server,
waits five minutes,
and then reads them back to check that their contents are still correct.
.IP \fIworm\fP
.kW \fIworm\fP
This is a self-replicating program that can be used to test the process
and segment server running on each host in the pool.
.br
Usage:
.sC
worm [-d] [-k]
.eC
The
.B \-d
option increases the amount of diagnostics produced.
If
.I worm
is called with the
.B \-k
option,
all worms currently running on the pool will be told to terminate.
.mH
Overview of the performance test programs available
.LP
.IP \fIdhrystone\fP 12
.kW \fIdhrystone\fP
.IP \fIdhrystone2\fP
.kW \fIdhrystone2\fP
These programs will give a quick impression of the cpu and
C-compiler performance for a particular system.
.I Dhrystone
performs a predefined number of integer,
structure and string operations,
and gives a performance rating according to the time used.
The program
.I dhrystone2
is a newer version in which the number of iterations
is specified interactively.
It is also more verbose.
.IP \fITperf_milli\fP
.kW \fITperf_milli\fP
.IP \fITperf_null\fP
.kW \fITperf_null\fP
.IP \fITperf_thrdsw\fP
.kW \fITperf_thrdsw\fP
.IP \fITperf_thrdsw.preempt\fP
.kW \fITperf_thrdsw.preempt\fP
These programs test the performance of the system calls
.I sys_milli ,
.I sys_null and
.I threadswitch respectively.
.IP \fITperf_disk\fP
.kW \fITperf_disk\fP
This program tests the performance of the
.I vdisk
server.
.br
Usage:
.sC
Tperf_disk [-w] [-d duration] [-b bytes] diskcap
.eC
By default,
.I Tperf_disk
only tests disk reads for various block sizes.
The
.B \-w
option causes (destructive!) disk writes to be done as well.
The
.B \-d
option restricts the test per block size to the specified
number of seconds (default is 30 seconds).
The
.B \-b
option specifies the number of bytes to be read or written
per iteration (default is 64K).
.IP \fITperf_tats\fP
.kW \fITperf_tats\fP
This program measures the performance of
.I mutex
operations,
.I thread
creation,
local and remote RPCs for various sizes,
and \*(Bs operations.
.br
Usage:
.sC
Tperf_tats [-i] [-m machine] [multiplier]
.eC
The
.B \-i
option causes the program to wait for a newline
on standard input before starting the tests.
The
.B \-m
option specifies the machine on which the child
process has to run during the remote RPC tests (otherwise
an arbitrary one from the pool is selected).
The optional \*<multiplier\*> multiplies the number of tests
performed by the amount specified.
.IP \fITperf_grp\fP
.kW \fITperf_grp\fP
This program tests the performance of the group communication in \*(Am.
The program must be started by \*<gax\*> (see
.I gax (U))
as follows:
.sC
gax -p pool Tperf_grp ncpu nsender size \e
	nmess large resil check recover debug
.eC
The parameters have the following meaning:
.RS
.IP \*<ncpu\*> 10
The number of group members.
.IP \*<nsender\*>
The number of members sending data to the group;
this should be in the range 1..\*<ncpu\*>.
.IP \*<size\*>
The size of the messages sent.
The current group implementation limits this amount to about 8000 bytes.
.IP \*<nmess\*>
The number of messages sent by each sender.
.IP \*<large\*>
Determines which variant of the group protocol will be used;
see
.I group (L).
.IP \*<resil\*>
The resilience degree of the group communication;
this should be in the range 0..\*<ncpu\*>.
.IP \*<check\*>
If non-zero,
the data received will be checked for correctness.
.IP \*<recover\*>
If non-zero,
.I Tperf_grp
will try to recover from group communication errors.
.IP \*<debug\*>
A flag that will be passed to the kernel to set the group
communication debugging level.
.RE
.IP \fITpclient\fP
.kW \fITpclient\fP
.IP \fITpserver\fP
.kW \fITpserver\fP
.IP \fITpcomp\fP
.kW \fITpcomp\fP
These programs can be used to measure the raw RPC performance of the system.
.br
Usage:
.sC
Tpserver port
Tpclient [-r] port size count
Tpcomp port1 port2 size count
.eC
The program
.I Tpserver
must be started first, with an ASCII port argument that will be used
during the test (e.g., \*<myport\*>).
.br
The program
.I Tpclient
will perform \*<count\*> RPCs of size \*<size\*> with
.I Tpserver ,
and reports the latency and throughput measured.
The
.B \-r
flag causes the data to be sent in the reverse direction.
If
.I Tpclient
is started with \*<count\*> equal to zero,
.I Tpserver
will be told to exit.
.br
The program
.I Tpcomp
acts as a client of the two
.I Tpservers
specified by the port arguments.
It will check the integrity of the random data sent over to both servers,
and reports the measured throughput like
.I Tpclient .
.IP \fITrpc_client\fP
.kW \fITrpc_client\fP
.IP \fITrpc_server\fP
.kW \fITrpc_server\fP
.IP \fITrpc_comp\fP
.kW \fITrpc_comp\fP
Like
.I Tpclient ,
.I Tpserver
and
.I Tpcomp ,
these programs measure the raw RPC performance.
The difference is that these programs
use a new RPC interface that allows RPCs greater than 30000 bytes.
.br
Usage:
.sC
Trpc_server port maxsize rpctime
Trpc_client [-m measure] [-r] port size count
Trpc_comp port1 port2 size count
.eC
The program
.I Trpc_server
must be started first, with an ASCII port argument that will be used
during the test (e.g., \*<myport\*>).
Parameter \*<maxsize\*> specifies the maximum RPC size that
may be performed with this server.
Parameter \*<rpctime\*> specifies the number of milliseconds
the server will wait before sending the reply of an RPC.
.br
The program
.I Trpc_client
will perform \*<count\*> RPCs of size \*<size\*> with
.I Trpc_server ,
and reports the latency and throughput measured.
The
.B \-m
option will cause a progress report
to be written each time \*<measure\*> RPCs have been completed.
The
.B \-r
flag will cause the data to be sent in the reverse direction.
If
.I Trpc_pclient
is started with \*<count\*> equal to zero,
.I Trpc_pserver
will be told to exit.
.br
The program
.I Trpc_comp
acts as a client of the two
.I Trpc_servers
specified by the port arguments.
It will check the integrity of the random data sent over to both servers,
and reports the measured throughput like
.I Trpc_client .
.IP \fITrrpc_client\fP
.kW \fITrrpc_client\fP
.IP \fITrrpc_server\fP
.kW \fITrrpc_server\fP
.IP \fITrrpc_start\fP
.kW \fITrrpc_start\fP
These programs test the performance of the replicated RPC package.
.br
Usage:
.sC
Trrpc_server
Trrpc_client size count
Trrpc_start
.eC
First,
one or more replicas of
.I Trrpc_server
must be started on background.
Next,
.I Trrpc_client
should be started on background.
The parameters specify the size and number of RPCs respectively.
Finally,
.I Trrpc_start
should be executed.
It will tell
.I Trrpc_client
to start the performance test as soon as the
.I Trrpc_servers
are completely initialized.
.SH
See Also
.LP
Tam_signals(T),
Tbullet(T),
Tpipe(T),
Tsignal(T),
Tsoap(T).
