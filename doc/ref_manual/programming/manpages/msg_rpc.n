.\"	@(#)msg_rpc.n	1.3	96/02/15 16:53:00
.\"
.\" Copyright 1996 Vrije Universiteit, The Netherlands.
.\" For full copyright and restrictions on use see the file COPYRIGHT in the
.\" top level of the Amoeba distribution.
.\"
.aU
	Software: Mark D. Wood, 1992
	Document: Mark D. Wood, Nov 1992
	Modified: Gregory J. Sharp, Feb 1996
.aE
.mT "msg_rpc" L "libamoeba.a"
fault-tolerant message-based remote procedure call routines
.SH
Synopsis
.LP
.sC L
#include "rrpc/msg_rpc.h"

CTXT_NOD *
ctx_define_context(context_name, replicated, num_state_domains,
		   state_xfer_routine, state_rcv_routine);
void	ctx_define_entry(entry, func, entry_name);
CTXT_NODE *ctx_lookup_context(context_name);
int	ctx_rpc(ctxtp, entry, *req_mp, **reply);
.eC
.SH
Description
.LP
These routines, together with the message library routines (see
.I msg (L))
provide a high-level mechanism for making remote procedure calls.
An application using these routines may be made fault-tolerant by following
some simple rules in constructing the program,
and then simply running multiple replicas of each application component.
In particular, the program components must be constructed as
.I state-machines .
Programs must be completely deterministic, with their outputs
determined solely by the sequence of messages received.
.mH
Error codes
.LP
The
.I ctx_rpc
routine returns \(mi1 if the remote procedure call fails, which happens
if there is a total failure of the service.
.sH
ctx_define_context
.LP
.sC
CTXT_NODE
*ctx_define_context(context_name, replicated, num_state_domains,
		    state_xfer_routine, state_rcv_routine)
char *context_name;
int replicated;
int num_state_domains;
message *(*state_xfer_routine[])(int);
int (*state_rcv_routine[])(int, message *);
.eC
.kW "\fIctx_define_context\fP"
.LP
A program wishing to make or receive remote procedure calls using
these library routines must first identify itself to the library.
A program gives itself an identity by calling the routine
.I ctx_define_context .
The
.I context_name
parameter specifies the name by which the program (or replicated set
of programs) is to be known by.
If only a single replica of the program is to be run, then the
.I replicated
parameter should have the value of false (zero);
this enables certain performance optimizations to be applied.
Otherwise, the value of
.I replicated
should be true (one).
.LP
When a new server replica joins an existing service, it is
required that the new replica start processing requests in the same
state as the existing replicas.
This generally will require state to be transferred from the existing
replicas to the new replica.
The state transfer takes place by transferring a sequence of state domains,
with one message per state domain.
The number of state domains to be transferred is specified as the parameter
.I num_state_domains .
.LP
The state transfer takes place atomically whenever a new replica joins
a service which already has replicas running with the same name, as
defined by
.I ctx_define_context .
To accomplish the state transfer, the library repeatedly invokes the specified
.I state_xfer_routine
in an existing member of the group, calling the routine with the
domain number as the parameter.
The domains are numbered from zero to the highest allowed domain number
(currently, two).
In the new replica, the library calls the specified
.I state_rcv_routine
once for each domain message generated by
.I state_xfer_routine ,
passing as parameters the domain number and a pointer to the corresponding
message.
.LP
All replicas of a service must call
.I ctx_define_context
with the same parameter values.
.sH
ctx_define_entry
.LP
.sC
void
ctx_define_entry(entry, func, entry_name)
int entry;
message *(*func)(message *);
char *entry_name;
.eC
.kW "\fIctx_define_entry\fP"
.LP
To receive server requests, a program declares to the library the
server routines to be called when requests are received.
Server procedures are identified by their entry number;
up to sixteen (16) entry points may be defined, numbered from zero to fifteen.  A server procedure is declared by calling
.I ctx_define_entry .
The parameters are the entry number to be associated with this
routine, the address of the routine to call, and the name of the
routine as a string.
Upon receipt of a message for this entry point,
the library automatically calls the specified routine, passing a
pointer to the message as the parameter.
The routine returns a pointer to the message to be returned to the client.
.sH
ctx_lookup_context
.LP
.sC
CTXT_NODE
*ctx_lookup_context(context_name)
char *context_name;
.eC
.kW "\fIctx_lookup_context\fP"
.LP
To make a remote procedure call, a program must first lookup the name
of the appropriate service.
A service is looked up by calling
.I ctx_lookup_context ,
passing as a parameter the name of the service as a string.
.I Ctx_lookup_context
returns a pointer to an internal data structure;
this pointer is used from then on to identify the service.
.sH
ctx_rpc
.LP
.sC
int
ctx_rpc(ctxtp, entry,, req_mp, reply_mp)
CTXT_NODE *ctxtp;
int entry;
message *req_mp;
message **reply;
.eC
.kW "\fIrpc\fP"
.LP
A remote procedure call is carried out by calling
.I ctx_rpc ,
which takes four parameters.
The first parameter is the pointer identifying the service, as obtained by
calling
.I ctx_lookup_context .
The second parameter is the entry number of the procedure and the
third parameter is a pointer to the message which is to be passed to
that procedure.
The fourth parameter is a pointer to a message pointer.
The
.I ctx_rpc
routine sets this pointer to point to the reply message.
.LP
The main thread of a server program will typically call
.I thread_exit
(see
.I thread (L))
after executing the necessary initialization routines.
The library will automatically invoke the server routines as necessary.
.SH
Warning
.LP
Note that these routines employ the
.I msg
routines (see
.I msg (L)).
.SH
Examples
.LP
There are examples showing how these routines are used in the sources.
They are in the directory
.I src/test/lib/amoeba .
.SH
See Also
.LP
msg(L),
msg_grp(L),
rpc(L).
