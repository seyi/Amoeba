.\"	@(#)flex.n	1.5	96/02/16 10:58:30
.aU
	Software: Vern Paxson, Kevin Gong
	Document: ??, 13 May 1987
		convert to Amoeba format by Gregory J. Sharp, July 1990
     Send comments to:

     Vern Paxson
     Real Time Systems
     Bldg. 46A
     Lawrence Berkeley Laboratory
     1 Cyclotron Rd.
     Berkeley, CA 94720

     (415) 486-6411

     vern@lbl-{csam,rtsg}.arpa
     ucbvax!lbl-csam.arpa!vern
.aE
.mT "flex" U
fast lexical analyzer generator
.SH
Synopsis
.LP
.sC L
flex [-dfirstvFILT -c[efmF] -Sskeleton_file] [filename]
.eC
.SH
Description
.LP
.kW "lex"
.kW "lexical analyzer generator"
.I Flex
is a rewrite of
.I lex
intended to right some of that tool's deficiencies: in particular,
.I flex
generates lexical analyzers much faster, and the analyzers use
smaller tables and run faster.
.mH
Options
.LP
.IP \fB\-d\fP 9
This makes the generated scanner run in
.I debug
mode.
Whenever a pattern is recognized the scanner will write to
.I stderr
a line of the form:
.sC
    --accepting rule #n
.eC
Rules are numbered sequentially with the first one being 1.
.IP \fB\-f\fP
This has the same effect as
.I lex 's
.B \-f
flag (do not compress the scanner tables);
the mnemonic changes from
.I "fast compilation"
to either
.I "full table"
or
.I "fast scanner" .
The actual compilation takes
.I longer ,
since
.I flex
is I/O bound writing out the big table.
This option is equivalent to
.B \-cf
(see below).
.IP \fB\-i\fP
This instructs
.I flex
to generate a
.I case-insensitive
scanner.
The case of letters given in the
.I flex
input patterns will be ignored,
and the rules will be matched regardless of case.
The matched text given in
.I yytext
will have the preserved case (i.e., it will not be folded).
.IP \fB\-r\fP
specifies that the scanner uses the
.B REJECT
action.
.IP \fB\-s\fP
causes the
.I "default rule"
(that unmatched scanner input is echoed to
.I stdout )
to be suppressed.
If the scanner encounters input that does not match any of its rules,
it aborts with an error.
This option is useful for finding holes in a scanner's rule set.
.IP \fB\-t\fP
puts the result on standard output instead of the file
.I lex.yy.c .
.IP \fB\-v\fP
has the same meaning as for
.I lex
(print to
.I stderr
a summary of statistics of the generated scanner).
Many more statistics are printed, though, and the summary spans several lines.
Most of the statistics are meaningless to the casual
.I flex
user.
.IP \fB\-F\fP
specifies that the
.I fast
scanner table representation should be used.
This representation is about as fast as the full table representation
.B (\-f) ,
and for some sets of patterns will be considerably smaller (and for
others, larger).
In general, if the pattern set contains both ``keywords'' and a catch-all,
``identifier'' rule, such as in the set:
.sC
"case"    return ( TOK_CASE );
"switch"  return ( TOK_SWITCH );
...
"default" return ( TOK_DEFAULT );
[a-z]+    return ( TOK_ID );
.eC
then it is better using the full table representation.
If only the identifier rule is present, and a hash table or some
such thing is used to detect the keywords, it is better to use
.B \-F .
.br
This option is equivalent to
.B \-cF
(see below).
.IP \fB\-I\fP
instructs
.I flex
to generate an
.I interactive
scanner.
Normally, scanners generated by
.I flex
always look ahead one character before deciding that a rule has been matched.
At the possible cost of some scanning overhead (it is not clear that more
overhead is involved),
.I flex
will generate a scanner which only looks ahead when needed.
Such scanners are called
.I interactive
because to write a scanner for an interactive system such
as a command shell, it will probably need the user's input to be terminated
with a newline, and without
.B \-I
the user will have to type a character in addition to the newline in order
to have the newline recognized.
This leads to dreadful interactive performance.
.IP
If all this seems to confusing, here is the general rule: if a human will
be typing in input to a scanner, use
.B \-I,
otherwise do not; if it does not matter how fast the scanner runs and
it is not necessary to make any assumptions about the input to the scanner,
always use
.B \-I .
.sp
Note,
.B \-I
cannot be used in conjunction with
.I full
or
.I "fast tables" ,
i.e., the
.B \-f ,
.B \-F ,
.B \-cf ,
or
.B \-cF
flags.
.IP \fB\-L\fP
instructs
.I flex
to not generate
.I #line
directives (see below).
.IP \fB\-T\fP
makes
.I flex
run in
.I trace
mode.
It will generate a lot of messages to standard out concerning the form of the
input and the resultant non-deterministic and deterministic finite automatons.
This option is mostly for use in maintaining
.I flex .
.IP \fB\-c[efmF]\fP
controls the degree of table compression.
.B \-ce
directs
.I flex
to construct
.I "equivalence classes" ,
i.e., sets of characters
which have identical lexical properties (for example, if the only
appearance of digits in the
.I flex
input is in the character class [0-9] then the
digits 0, 1, ..., 9 will all be put in the same equivalence class).
.B \-cf
specifies that the
.I full
scanner tables should be generated \-
.I flex
should not compress the tables by taking advantages of similar
transition functions for different states.
.B \-cF
specifies that the alternate fast scanner representation (described
above under the
.B \-F
flag) should be used.
.B \-cm
directs
.I flex
to construct
.I "meta-equivalence classes" ,
which are sets of equivalence classes (or characters, if equivalence
classes are not being used) that are commonly used together.
A lone
.B \-c
specifies that the scanner tables should be compressed but neither
equivalence classes nor meta-equivalence classes should be used.
.sp
The options
.B \-cf
or
.B \-cF
and
.B \-cm
do not make sense together \- there is no opportunity for meta-equivalence
classes if the table is not being compressed.  Otherwise the options
may be freely mixed.
.sp
The default setting is
.B \-cem
which specifies that
.I flex
should generate equivalence classes and meta-equivalence classes.
This setting provides the highest degree of table compression.
One can trade off faster-executing scanners at the cost of larger tables with
the following generally being true:
.sC
slowest            smallest
          -cem
          -ce
          -cm
          -c
          -c{f,F}e
          -c{f,F}
fastest            largest
.eC
.IP \fB\-S\fPskeleton_file 16
overrides the default skeleton file from which
.I flex
constructs its scanners.
This option will not be needed unless doing
.I flex
maintenance or development.
.SH
Incompatibilities With Lex
.LP
.I flex
is fully compatible with
.I lex
with the following exceptions:
.IP \(bu
There is no run-time library to link with.
It is not necessary to specify
.B \-ll
when linking, and a main program must be supplied.
(Hacker's note: since the
.I lex
library contains a
.I main()
which simply calls
.I yylex() ,
it is possible to be lazy and not supply a main program and link with
.B \-ll .)
.IP \(bu
.I lex 's
.I %r
(Ratfor scanners) and
.I %t
(translation table) options are not supported.
.IP \(bu
The do-nothing
.B \-n
flag is not supported.
.IP \(bu
When definitions are expanded,
.I flex
encloses them in parentheses.
With
.I lex ,
the following
.sC
NAME    [A-Z][A-Z0-9]*
%%
foo{NAME}?      printf("Found it\en");
%%
.eC
will not match the string ``foo'' because when the macro
is expanded the rule is equivalent to ``foo[A-Z][A-Z0-9]*?''
and the precedence is such that the ``?'' is associated with
``[A-Z0-9]*''.
With
.I flex ,
the rule will be expanded to
``foo([A-z][A-Z0-9]*)?'' and so the string ``foo'' will match.
.IP \(bu
.I yymore
is not supported.
.IP \(bu
The undocumented
.I lex -scanner
internal variable
.I yylineno
is not supported.
.IP \(bu
If the input uses
.I REJECT,
.I flex
must be run with the
.B \-r
flag.
If it is omitted, the scanner will abort at run-time
with a message that the scanner was compiled without the flag being
specified.
.IP \(bu
The
.I input()
routine is not redefinable, though may be called to read characters
following whatever has been matched by a rule.
If
.I input()
encounters and end-of-file the normal
.I yywrap()
processing is done.  A ``real'' end-of-file is returned as
.I EOF .
.IP
Input can be controlled by redefining the
.cW YY_INPUT
macro.
.cW YY_INPUT 's
calling sequence is
.sC
YY_INPUT(buf, result, max_size)
.eC
Its action is to place up to
.I max_size
characters in the character buffer
.I buf
and return in the integer variable
.I result
either the number of characters read or the constant
.cW YY_NULL
(0 on
.UX
systems) to indicate EOF.
The default
.cW YY_INPUT
reads from the file-pointer
.I yyin
(which is by default
.I stdin ),
so if a change to the input file is required, it is not necessary to redefine
.cW YY_INPUT
\- just point
.I yyin
at the input file.
.IP
A sample redefinition of
.cW YY_INPUT
(in the first section of the input file):
.sC
%{
#undef YY_INPUT
#define YY_INPUT(buf, result, max_size) \e
    result = (buf[0] = getchar()) == EOF ? YY_NULL : 1;
%}
.eC
Things like keeping track of the
input line number can be added this way;
but do not expect the scanner to go very fast.
.IP \(bu
.I output
is not supported.
Output from the
.cW ECHO
macro is done to the file-pointer
.I yyout
(default
.I stdout ).
.IP \(bu
Trailing context is restricted to patterns which have either
a fixed-sized leading part or a fixed-sized trailing part.
For example, ``a*/b'' and ``a/b*'' are okay, but not ``a*/b*''.
This restriction is due to a bug in the trailing context
algorithm given in
.I "Principles of Compiler Design"
(and
.I "Compilers \- Principles, Techniques, and Tools" )
which can result in mismatches.
Try the following
.I lex
program
.sC
%%
x+/xy           printf("I found \e"%s\e"\en", yytext);
.eC
on the input ``xxy''.
If an arbitrary trailing context is unavoidable,
.I yyless
can be used to effect it.
.IP \(bu
.I flex
reads only one input file, while
.I lex 's
input is made up of the concatenation of its input files.
.SH
Enhancements
.LP
.IP \(bu
.I "Exclusive start-conditions"
can be declared by using
.I %x
instead of
.I %s .
These start-conditions have the property that when they are active,
.I "no other rules are active" .
Thus a set of rules governed by the same exclusive start condition
describe a scanner which is independent of any of the other rules in
the
.I flex
input.
This feature makes it easy to specify ``mini-scanners''
which scan portions of the input that are syntactically different
from the rest (e.g., comments).
.IP \(bu
.I flex
dynamically resizes its internal tables, so directives like ``%a 3000''
are not needed when specifying large scanners.
.IP \(bu
The scanning routine generated by
.I flex
is declared using the macro
.I YY_DECL .
By redefining this macro the routine's name and calling sequence can be changed.
For example, use
.sC
#undef YY_DECL
#define YY_DECL float lexscan( a, b ) float a, b;
.eC
to give it the name
.I lexscan ,
returning a float, and taking two floats as arguments.
.IP \(bu
.I flex
generates
.I #line
directives mapping lines in the output to
their origin in the input file.
.IP \(bu
Multiple actions can be put on the same line,
separated by semi-colons.
With
.I lex ,
the following
.sC
foo    handle_foo(); return 1;
.eC
is truncated to
.sC
    foo    handle_foo();
.eC
.I flex
does not truncate the action.
Actions that are not enclosed in
braces are terminated at the end of the line.
.IP \(bu
Actions can be begun with %{ and terminated with %}.
In this case,
.I flex
does not count braces to figure out where the
action ends \- actions are terminated by the closing
.I %} .
This feature is useful when the enclosed action has extraneous
braces in it (usually in comments or inside inactive #ifdef's)
that throw off the brace-count.
.IP \(bu
All of the scanner actions (e.g.,
.I ECHO ,
.I yywrap ...)
except the
.I unput()
and
.I input()
routines,
are written as macros, so they can be redefined if necessary
without requiring a separate library to link to.
.SH
Diagnostics
.IP "\fIflex scanner jammed\fP"
.br
A scanner compiled with
.B \-s
has encountered an input string which was not matched by any of its rules.
.IP "\fIflex input buffer overflowed\fP"
.br
A scanner rule matched a string long enough to overflow the
scanner's internal input buffer (as large as
.I BUFSIZ
in ``stdio.h'').
Edit
.I flexskelcom.h
and increase
.I YY_BUF_SIZE
and
.I YY_MAX_LINE
to increase this limit.
.IP "\fIREJECT used and scanner was not generated using \-r\fP"
.br
Just like it sounds.
The scanner uses
.I REJECT.
Run
.I flex
on the scanner description using the
.B \-r
flag.
.IP "\fIold-style lex command ignored\fP"
.br
The
.I flex
input contains a
.I lex
command (e.g., ``%n 1000'') which
is being ignored.
.SH
Bugs
.LP
Use of
.I unput()
or
.I input()
trashes the current
.I yytext
and
.I yyleng .
.LP
Use of
.I unput()
to push back more text than was matched can
result in the pushed-back text matching a beginning-of-line ('^')
rule even though it did not come at the beginning of the line.
.LP
Nulls are not allowed in
.I flex
inputs or in the inputs to scanners generated by
.I flex .
Their presence generates fatal errors.
.LP
Do not mix trailing context with the '|' operator used to
specify that multiple rules use the same action.
That is,
avoid constructs like:
.sC
foo/bar      |
bletch       |
bugprone     { ... }
.eC
They can result in subtle mismatches.
This is actually not a problem if there is only one rule using trailing
context and it is the first in the list (so the above example will actually
work okay).
The problem is due to fall-through in the action switch statement,
causing non-trailing-context rules to execute the
trailing-context code of their fellow rules.
This should be fixed, as it is a nasty bug and not obvious.
The proper fix is for
.I flex
to spit out a FLEX_TRAILING_CONTEXT_USED #define
and then have the backup logic in a separate table which is consulted for
each rule-match, rather than as part of the rule action.
The place to do the tweaking is in
.I add_accept()
\- any kind soul want
to be a hero?
.LP
The pattern:
.sC
x{3}
.eC
is considered to be variable-length for the purposes of trailing
context, even though it has a clear fixed length.
.LP
Due to both buffering of input and read-ahead, one cannot intermix
calls to, for example,
.I getchar()
with
.I flex
rules and expect it to work.
Call
.I input()
instead.
.LP
The total table entries listed by the
.B \-v
flag excludes the number of table entries needed to determine
what rule has been matched.  The number of entries is equal
to the number of DFA states if the scanner was not compiled
with
.B \-r ,
and greater than the number of states if it was.
.LP
The scanner run-time speeds have not been optimized as much as they deserve.
Van Jacobson's work shows that the scanner can go quite a bit faster still.
.SH
Files
.LP
.I flex.skel
skeleton scanner
.br
.I flex.fastskel
skeleton scanner for
.B \-f
and
.B \-F
.br
.I flexskelcom.h
common definitions for skeleton files
.br
.I flexskeldef.h
definitions for compressed skeleton file
.br
.I fastskeldef.h
definitions for
.B \-f ,
.B \-F
skeleton file.
.SH
See Also
.LP
M. E. Lesk and E. Schmidt,
.I "LEX \- Lexical Analyzer Generator" .
